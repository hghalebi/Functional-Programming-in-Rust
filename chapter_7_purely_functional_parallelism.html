<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Purely Functional Parallelism - Functional Programming in Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="A pedagogical guide inspired by the Red Book and Rust resources.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="chapter_1_introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="chapter_2_getting_started.html">Getting Started</a></li><li class="chapter-item expanded affix "><a href="chapter_3_functional_data_structures.html">Functional Data Structures</a></li><li class="chapter-item expanded affix "><a href="chapter_4_handling_errors.html">Handling Errors</a></li><li class="chapter-item expanded affix "><a href="chapter_5_strictness_and_laziness.html">Strictness and Laziness</a></li><li class="chapter-item expanded affix "><a href="chapter_6_purely_functional_state.html">Purely Functional State</a></li><li class="chapter-item expanded affix "><a href="chapter_7_purely_functional_parallelism.html" class="active">Purely Functional Parallelism</a></li><li class="chapter-item expanded affix "><a href="chapter_8_property_based_testing.html">Property-Based Testing</a></li><li class="chapter-item expanded affix "><a href="chapter_9_parser_combinators.html">Parser Combinators</a></li><li class="chapter-item expanded affix "><a href="chapter_10_monoids.html">Monoids</a></li><li class="chapter-item expanded affix "><a href="chapter_11_monads.html">Monads</a></li><li class="chapter-item expanded affix "><a href="chapter_12_applicative.html">Applicative and Traversable</a></li><li class="chapter-item expanded affix "><a href="chapter_13_effects.html">External Effects and I/O</a></li><li class="chapter-item expanded affix "><a href="chapter_14_local_effects.html">Local Effects and Mutable State</a></li><li class="chapter-item expanded affix "><a href="chapter_15_streaming.html">Stream Processing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Functional Programming in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-7-purely-functional-parallelism"><a class="header" href="#chapter-7-purely-functional-parallelism">Chapter 7: Purely Functional Parallelism</a></h1>
<p>In this chapter, we will explore the design of a purely functional library for creating parallel and asynchronous computations. As we did in previous chapters, we won't jump straight to the implementation. Instead, we'll follow a process of <em>designing the API first</em>. We'll verify that our API is expressive and follows algebraic laws, and only <em>then</em> will we worry about how to implement it efficiently.</p>
<p>This journey is particularly interesting in Rust compared to Scala. In Scala, we can often be loose with thread safety due to the garbage collector and the JVM's memory model. In Rust, however, the compiler forces us to be rigorous about ownership and sharing across threads from day one. We will see how traits like <code>Send</code>, <code>Sync</code>, and types like <code>Arc</code> become fundamental building blocks of our parallel algebra.</p>
<h2 id="71-choosing-a-data-type-and-functions"><a class="header" href="#71-choosing-a-data-type-and-functions">7.1 Choosing a Data Type and Functions</a></h2>
<p>Our goal is to create a library that can describe parallel computations. Let's imagine we want to sum a list of integers in parallel. We might use a divide-and-conquer approach:</p>
<pre><code class="language-rust ignore">fn sum(ints: &amp;[i32]) -&gt; i32 {
    if ints.len() &lt;= 1 {
        ints.get(0).unwrap_or(&amp;0).clone() // equivalent to headOption.getOrElse(0)
    } else {
        let (l, r) = ints.split_at(ints.len() / 2);
        let sum_l = sum(l);
        let sum_r = sum(r);
        sum_l + sum_r
    }
}</code></pre>
<p>This implementation is sequential. To make it parallel, we need a way to say "compute <code>sum_l</code> and <code>sum_r</code> in parallel". Let's invent a container type, let's call it <code>Par&lt;A&gt;</code> (short for Parallel), that represents a computation of type <code>A</code> that <em>might</em> be running in another thread.</p>
<p>We need a way to take an unevaluated <code>A</code> and wrap it in a <code>Par&lt;A&gt;</code>. In Scala, this is <code>Par.unit</code>.
And we need a way to get the result out. Scala calls this <code>run</code>.</p>
<pre><code class="language-rust ignore">pub struct Par&lt;A&gt;(...);

impl&lt;A&gt; Par&lt;A&gt; {
    pub fn unit(a: A) -&gt; Par&lt;A&gt; { ... }
    pub fn run(self) -&gt; A { ... }
}</code></pre>
<p>If we change <code>sum</code> to use <code>Par</code>:</p>
<pre><code class="language-rust ignore">fn sum(ints: &amp;[i32]) -&gt; i32 {
    if ints.len() &lt;= 1 {
        // ...
    } else {
        let (l, r) = ints.split_at(ints.len() / 2);
        // unit returns Par&lt;i32&gt; immediately
        let sum_l: Par&lt;i32&gt; = Par::unit(sum(l)); 
        let sum_r: Par&lt;i32&gt; = Par::unit(sum(r));
        // get results (run)
        sum_l.run() + sum_r.run()
    }
}</code></pre>
<p>But wait! <code>Par::unit</code> takes an <em>evaluated</em> value <code>A</code>. If we pass <code>sum(l)</code> to it, <code>sum(l)</code> is evaluated <em>before</em> <code>unit</code> is called, on the current thread. We haven't achieved parallelism; we've just wrapped the result!</p>
<p>We need a primitive that takes a <em>lazy</em> argument or a closure. Let's call it <code>fork</code>.</p>
<pre><code class="language-rust ignore">pub fn fork&lt;A, F&gt;(a: F) -&gt; Par&lt;A&gt; 
where F: FnOnce() -&gt; Par&lt;A&gt; + Send + 'static { ... }</code></pre>
<p>In Rust, strict evaluation is the default. To prevent immediate execution, we pass a closure (a thunk). <code>fork</code> should take a thunk that returns a <code>Par&lt;A&gt;</code>, and run that thunk in a separate thread.</p>
<p>However, <code>fork</code> shouldn't just run <em>anything</em>. It specifically handles <code>Par</code>. To combine results, we need <code>map2</code>:</p>
<pre><code class="language-rust ignore">pub fn map2&lt;A, B, C, F&gt;(pa: Par&lt;A&gt;, pb: Par&lt;B&gt;, f: F) -&gt; Par&lt;C&gt;
where F: Fn(A, B) -&gt; C { ... }</code></pre>
<p>With <code>unit</code>, <code>fork</code>, and <code>map2</code>, our <code>sum</code> looks like this:</p>
<pre><code class="language-rust ignore">fn sum(ints: &amp;[i32]) -&gt; Par&lt;i32&gt; {
    if ints.len() &lt;= 1 {
        Par::unit(ints.get(0).copied().unwrap_or(0))
    } else {
        let (l, r) = ints.split_at(ints.len() / 2);
        Par::map2(
            Par::fork(|| sum(l)),
            Par::fork(|| sum(r)),
            |a, b| a + b
        )
    }
}</code></pre>
<p>This looks purely functional! <code>sum</code> now returns a <em>description</em> of a parallel computation (<code>Par&lt;i32&gt;</code>), which we can execute later by calling <code>run</code>.</p>
<h2 id="72-a-function-representation-for-par"><a class="header" href="#72-a-function-representation-for-par">7.2 A Function Representation for <code>Par</code></a></h2>
<p>What should <code>Par&lt;A&gt;</code> actually <em>be</em>?
In the book, <code>Par[A]</code> is defined as a function that takes an <code>ExecutorService</code> and returns a <code>Future[A]</code>.</p>
<pre><code class="language-scala">type Par[A] = ExecutorService =&gt; Future[A]
</code></pre>
<p>In Rust, this translates to something slightly more complex due to ownership.
We need an <code>Executor</code> trait (similar to <code>ExecutorService</code>).
We need a <code>Future</code> trait.
And <code>Par&lt;A&gt;</code> is a closure.</p>
<h3 id="the-rust-implementation-challenges"><a class="header" href="#the-rust-implementation-challenges">The Rust Implementation Challenges</a></h3>
<ol>
<li><strong>Object Safety</strong>: We want to pass <code>&amp;dyn Executor</code> around. This requires <code>Executor</code> to be "object safe". We cannot have generic methods like <code>submit&lt;T&gt;(...)</code> in an object-safe trait. We must use type erasure, e.g., <code>Box&lt;dyn Any + Send&gt;</code>.</li>
<li><strong>Thread Safety</strong>: Since <code>Par</code> is executed potentially on other threads, the closure defining it must be <code>Send</code> and <code>Sync</code>. We use <code>Arc</code> instead of <code>Rc</code> to allow shared ownership across threads.</li>
</ol>
<p>Here is our refined definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use std::any::Any;

#[allow(clippy::type_complexity)]
pub struct Par&lt;A&gt;(Arc&lt;dyn Fn(&amp;dyn Executor) -&gt; Box&lt;dyn Future&lt;Item=A&gt;&gt; + Send + Sync&gt;);
<span class="boring">}</span></code></pre></pre>
<p>This says: <code>Par&lt;A&gt;</code> assumes it can be shared (<code>Arc</code>), run concurrently (<code>Sync</code>), and sent across threads (<code>Send</code>). It takes an <code>Executor</code> and produces a <code>Future</code> yielding <code>A</code>.</p>
<h2 id="73-combinators"><a class="header" href="#73-combinators">7.3 Combinators</a></h2>
<p>Now we can implement the combinators.</p>
<h3 id="unit-and-lazy_unit"><a class="header" href="#unit-and-lazy_unit"><code>unit</code> and <code>lazy_unit</code></a></h3>
<p><code>unit</code> wraps a value immediately.
<code>lazy_unit</code> wraps a computation lazily by combining <code>unit</code> and <code>fork</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn unit&lt;A: Clone + Send + Sync + 'static&gt;(a: A) -&gt; Par&lt;A&gt; {
    Par::new(move |_| Box::new(UnitFuture(a.clone())))
}

pub fn lazy_unit&lt;A, F&gt;(a: F) -&gt; Par&lt;A&gt; 
where A: Clone + Send + Sync + 'static, F: Fn() -&gt; A + Send + Sync + 'static + Clone {
    fork(move || unit(a()))
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: The <code>Clone</code> bounds are often necessary in our simple implementation because the description of a parallel computation might be reused or re-executed. In a production library like <code>rayon</code>, generic lifetimes are handled more carefully to avoid excessive cloning.</p>
</blockquote>
<h3 id="map2"><a class="header" href="#map2"><code>map2</code></a></h3>
<p><code>map2</code> is where the magic happens. It combines two parallel computations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn map2&lt;A, B, C, F&gt;(pa: Par&lt;A&gt;, pb: Par&lt;B&gt;, f: F) -&gt; Par&lt;C&gt; {
    Par::new(move |es| {
        let fa = (pa.0)(es); // start A
        let fb = (pb.0)(es); // start B
        let a = fa.get();    // wait for A
        let b = fb.get();    // wait for B
        Box::new(UnitFuture(f(a, b)))
    })
}
<span class="boring">}</span></code></pre></pre>
<h3 id="fork"><a class="header" href="#fork"><code>fork</code></a></h3>
<p><code>fork</code> is responsible for shifting execution to a separate logical thread.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fork&lt;A, F&gt;(a: F) -&gt; Par&lt;A&gt; {
    Par::new(move |es| {
        // Submit a task to the executor
        let future = es.submit(wrapped_task);
        // Return a future that waits for the result
        ...
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="74-laws-and-deadlocks"><a class="header" href="#74-laws-and-deadlocks">7.4 Laws and Deadlocks</a></h2>
<p>An important property we expect is:
<code>fork(x) == x</code></p>
<p>Forking a computation shouldn't change its result, only <em>where</em> it runs.
However, with a fixed-size thread pool, naïve implementations of <code>fork</code> can deadlock!
If the thread pool has 1 thread:</p>
<ol>
<li><code>fork(fork(x))</code> is called.</li>
<li>The outer <code>fork</code> consumes the thread.</li>
<li>It tries to run the inner <code>fork</code>.</li>
<li>The inner <code>fork</code> waits for a thread... but the only thread is blocked waiting for the inner <code>fork</code>!</li>
</ol>
<p>This teaches us that <strong>API design is not just about types, but about runtime semantics and laws</strong>. A correct <code>Par</code> implementation for fixed-size pools requires non-blocking futures (using callbacks), which allows the thread to be released while waiting.</p>
<h2 id="75-derived-combinators"><a class="header" href="#75-derived-combinators">7.5 Derived Combinators</a></h2>
<p>Using <code>map2</code>, <code>unit</code>, and <code>fork</code>, we can derive:</p>
<ul>
<li><code>async_f</code>: Lift a function <code>A -&gt; B</code> to <code>A -&gt; Par&lt;B&gt;</code>.</li>
<li><code>sequence</code>: Convert <code>Vec&lt;Par&lt;A&gt;&gt;</code> to <code>Par&lt;Vec&lt;A&gt;&gt;</code>.</li>
<li><code>par_filter</code>: Filter a list in parallel.</li>
<li><code>map</code>: Derive <code>map</code> from <code>map2</code> and <code>unit</code>.</li>
</ul>
<h3 id="exercise-711-choice"><a class="header" href="#exercise-711-choice">Exercise 7.11: <code>choice</code></a></h3>
<p>We realized we can choose between two computations based on a boolean condition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn choice&lt;A&gt;(cond: Par&lt;bool&gt;, t: Par&lt;A&gt;, f: Par&lt;A&gt;) -&gt; Par&lt;A&gt;
<span class="boring">}</span></code></pre></pre>
<p>This naturally generalizes to <code>choice_n</code> (choosing from a list) and finally:</p>
<h3 id="exercise-713-flat_map-chooser"><a class="header" href="#exercise-713-flat_map-chooser">Exercise 7.13: <code>flat_map</code> (chooser)</a></h3>
<p>The most general form of dynamic choice is <code>flat_map</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn flat_map&lt;A, B, F&gt;(pa: Par&lt;A&gt;, f: F) -&gt; Par&lt;B&gt;
where F: Fn(A) -&gt; Par&lt;B&gt;
<span class="boring">}</span></code></pre></pre>
<p><code>flat_map</code> allows the structure of the computation to depend on the <em>result</em> of previous computations.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter, we built a functional parallelism library. We saw how:</p>
<ol>
<li><strong>Pure descriptions</strong> (<code>Par</code>) separate the "what" from the "how" (the <code>Executor</code>).</li>
<li><strong>Strictness in Rust</strong> requires explicit thunks or closures (like <code>F: Fn() -&gt; A</code>) to achieve laziness.</li>
<li><strong>Thread safety</strong> in Rust is explicit (<code>Send</code>, <code>Sync</code>, <code>Arc</code>), ensuring our parallel library prevents data races at compile time—a guarantee Scala cannot easily provide.</li>
</ol>
<p>In the next chapter, we will explore <strong>Property-Based Testing</strong>, where we will use generative testing to verifying laws like <code>fork(x) == x</code> automatically.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_6_purely_functional_state.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="chapter_8_property_based_testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_6_purely_functional_state.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="chapter_8_property_based_testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
