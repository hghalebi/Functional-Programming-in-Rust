<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction - Functional Programming in Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="A pedagogical guide inspired by the Red Book and Rust resources.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="chapter_1_introduction.html" class="active">Introduction</a></li><li class="chapter-item expanded affix "><a href="chapter_2_getting_started.html">Getting Started</a></li><li class="chapter-item expanded affix "><a href="chapter_3_functional_data_structures.html">Functional Data Structures</a></li><li class="chapter-item expanded affix "><a href="chapter_4_handling_errors.html">Handling Errors</a></li><li class="chapter-item expanded affix "><a href="chapter_5_strictness_and_laziness.html">Strictness and Laziness</a></li><li class="chapter-item expanded affix "><a href="chapter_6_purely_functional_state.html">Purely Functional State</a></li><li class="chapter-item expanded affix "><a href="chapter_7_purely_functional_parallelism.html">Purely Functional Parallelism</a></li><li class="chapter-item expanded affix "><a href="chapter_8_property_based_testing.html">Property-Based Testing</a></li><li class="chapter-item expanded affix "><a href="chapter_9_parser_combinators.html">Parser Combinators</a></li><li class="chapter-item expanded affix "><a href="chapter_10_monoids.html">Monoids</a></li><li class="chapter-item expanded affix "><a href="chapter_11_monads.html">Monads</a></li><li class="chapter-item expanded affix "><a href="chapter_12_applicative.html">Applicative and Traversable</a></li><li class="chapter-item expanded affix "><a href="chapter_13_effects.html">External Effects and I/O</a></li><li class="chapter-item expanded affix "><a href="chapter_14_local_effects.html">Local Effects and Mutable State</a></li><li class="chapter-item expanded affix "><a href="chapter_15_streaming.html">Stream Processing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Functional Programming in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-1-what-is-functional-programming"><a class="header" href="#chapter-1-what-is-functional-programming">Chapter 1: What is functional programming?</a></h1>
<p>Functional programming (FP) is based on a simple premise with far-reaching implications: we construct our programs using only pure functions—in other words, functions that have no side effects. What are side effects? A function has a side effect if it does something other than simply return a result, for example:</p>
<ul>
<li>Modifying a variable</li>
<li>Modifying a data structure in place</li>
<li>Setting a field on an object</li>
<li>Throwing an exception or halting with an error</li>
<li>Printing to the console or reading user input</li>
<li>Reading from or writing to a file</li>
<li>Drawing on the screen</li>
<li><strong>Calling an external API (like an LLM or Database)</strong></li>
</ul>
<p>We’ll provide a more precise definition of side effects later in this chapter, but consider what programming would be like without the ability to do these things. It may be difficult to imagine. How is it even possible to write useful Agentic workflows at all? If we can't call APIs or update memory, how do our Agents do anything?</p>
<p>The answer is that functional programming is a restriction on <em>how</em> we write programs, but not on <em>what</em> programs we can express. Over the course of this book, we’ll learn how to express all of our Agentic workflows without side effects, and that includes programs that perform I/O, handle errors, and manage context. We’ll learn how following the discipline of FP is tremendously beneficial because of the increase in modularity that we gain from programming with pure functions (which we can think of as <strong>Deterministic Tools</strong>). Because of their modularity, these tools are easier to test, reuse, parallelize, generalize, and reason about. Furthermore, pure functions are much less prone to bugs (or hallucinations in logic).</p>
<p>In this chapter, we’ll look at a simple program with side effects and demonstrate some of the benefits of FP by removing these side effects. We’ll also discuss the benefits of FP more generally and define two important concepts—referential transparency and the substitution model.</p>
<h2 id="11-the-benefits-of-fp-a-simple-example"><a class="header" href="#11-the-benefits-of-fp-a-simple-example">1.1 The benefits of FP: a simple example</a></h2>
<p>Let’s look at an example that demonstrates some of the benefits of programming with pure functions. The point here is just to illustrate some basic ideas that we’ll return to throughout this book. This will also be your first exposure to Rust's syntax if you are new to the language.</p>
<h3 id="111-a-program-with-side-effects"><a class="header" href="#111-a-program-with-side-effects">1.1.1 A program with side effects</a></h3>
<p>Suppose we’re implementing a client to interact with an Large Language Model (LLM). We want to generate text completions and bill our users for the tokens they consume. We’ll begin with a Rust program that uses side effects in its implementation (also called an impure program).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Clone, Copy)] struct Completion { tokens: i32 }
</span><span class="boring">impl Completion { fn new() -&gt; Self { Completion { tokens: 100 } } }
</span><span class="boring">struct BillingService;
</span><span class="boring">impl BillingService { fn charge_usage(&amp;mut self, _tokens: i32) {} }
</span>struct LLMClient;

impl LLMClient {
    fn generate_completion(&amp;self, billing: &amp;mut BillingService) -&gt; Completion {
        let response = Completion::new();
        billing.charge_usage(response.tokens);
        response
    }
}
<span class="boring">fn main() {
</span><span class="boring">    let client = LLMClient;
</span><span class="boring">    let mut billing = BillingService;
</span><span class="boring">    let _ = client.generate_completion(&amp;mut billing);
</span><span class="boring">}</span></code></pre></pre>
<p>The line <code>billing.charge_usage(response.tokens)</code> is an example of a side effect. Charging for usage involves interaction with the outside world—suppose it requires contacting a database, updating a distributed quota system, or calling an external payment provider like Stripe.</p>
<p>But our function merely returns a <code>Completion</code> (the text response) and these other actions are happening on the side, hence the term “side effect.”</p>
<p>As a result of this side effect, the code is difficult to test. We don’t want our unit tests to actually contact the billing system and charge real money! This lack of testability is suggesting a design change: arguably, <code>LLMClient</code> shouldn’t have any knowledge baked into it about how to contact the billing system, nor should it have knowledge of how to persist transaction records. We can make the code more modular and testable by letting <code>LLMClient</code> be ignorant of these concerns and passing a <code>Billing</code> object into <code>generate_completion</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Clone, Copy)] struct Completion { tokens: i32 }
</span><span class="boring">impl Completion { fn new() -&gt; Self { Completion { tokens: 100 } } }
</span><span class="boring">struct BillingService;
</span><span class="boring">trait Billing { fn charge_usage(&amp;mut self, tokens: i32); }
</span><span class="boring">struct MockBilling;
</span><span class="boring">impl Billing for MockBilling { fn charge_usage(&amp;mut self, _tokens: i32) {} }
</span>struct LLMClient;

impl LLMClient {
    fn generate_completion(&amp;self, billing: &amp;mut dyn Billing) -&gt; Completion {
        let response = Completion::new();
        billing.charge_usage(response.tokens);
        response
    }
}
<span class="boring">fn main() {
</span><span class="boring">    let client = LLMClient;
</span><span class="boring">    let mut mock = MockBilling;
</span><span class="boring">    let _ = client.generate_completion(&amp;mut mock);
</span><span class="boring">}</span></code></pre></pre>
<p>Though side effects still occur when we call <code>billing.charge_usage</code>, we have at least regained some testability. <code>Billing</code> can be a trait (interface), and we can write a mock implementation of this trait that is suitable for testing. But that isn’t ideal either. We’re forced to make <code>Billing</code> a trait, when a concrete struct may have been fine otherwise, and any mock implementation will be awkward to use. For example, it might contain some internal state that we’ll have to inspect after the call to <code>generate_completion</code>, and our test will have to make sure this state has been appropriately modified (mutated) by the call.</p>
<p>Separate from the concern of testing, there’s another problem: it’s difficult to reuse <code>generate_completion</code>. Suppose we want to implement a "Chain of Thought" workflow where we generate 12 intermediate reasoning steps. Ideally we could just reuse <code>generate_completion</code> for this, perhaps calling it 12 times in a loop. But as it is currently implemented, that will involve contacting the billing system 12 times! That adds significant latency and load to our billing infrastructure.</p>
<h3 id="112-a-functional-solution-removing-the-side-effects"><a class="header" href="#112-a-functional-solution-removing-the-side-effects">1.1.2 A functional solution: removing the side effects</a></h3>
<p>The functional solution is to eliminate side effects and have <code>generate_completion</code> return the usage cost as a value in addition to returning the <code>Completion</code>. The concerns of processing the cost by checking quotas, persisting records, and so on, will be handled elsewhere.</p>
<p>Here’s what a functional solution might look like in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Clone)] struct AccountId;
</span><span class="boring">#[derive(Clone, Copy)] struct Completion { tokens: i32 }
</span><span class="boring">impl Completion { fn new() -&gt; Self { Completion { tokens: 100 } } }
</span><span class="boring">struct TokenUsage { account: AccountId, tokens: i32 }
</span><span class="boring">impl TokenUsage { fn new(account: AccountId, tokens: i32) -&gt; Self { TokenUsage { account, tokens } } }
</span>struct LLMClient;

impl LLMClient {
    fn generate_completion(&amp;self, account: &amp;AccountId) -&gt; (Completion, TokenUsage) {
        let response = Completion::new();
        (response, TokenUsage::new(account.clone(), response.tokens))
    }
}
<span class="boring">fn main() {
</span><span class="boring">    let client = LLMClient;
</span><span class="boring">    let account = AccountId;
</span><span class="boring">    let _ = client.generate_completion(&amp;account);
</span><span class="boring">}</span></code></pre></pre>
<p>Here we’ve separated the concern of <em>creating</em> a usage record from the <em>processing</em> of that record. The <code>generate_completion</code> function now returns a <code>TokenUsage</code> as a value along with the <code>Completion</code>. We’ll see shortly how this lets us reuse it more easily to generate multiple completions with a single transaction. But what is <code>TokenUsage</code>? It’s a data type we just invented containing an <code>AccountId</code> and an amount, equipped with a handy function, <code>combine</code>, for combining usage logs for the same Account:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(PartialEq, Clone)] struct AccountId;
</span>struct TokenUsage {
    account: AccountId,
    tokens: i32,
}

impl TokenUsage {
    fn combine(&amp;self, other: &amp;TokenUsage) -&gt; Result&lt;TokenUsage, String&gt; {
        if self.account == other.account {
            Ok(TokenUsage {
                account: self.account.clone(),
                tokens: self.tokens + other.tokens,
            })
        } else {
            Err("Can't combine usage for different accounts".to_string())
        }
    }
}
<span class="boring">fn main() {
</span><span class="boring">   let acc = AccountId;
</span><span class="boring">   let u1 = TokenUsage { account: acc.clone(), tokens: 50 };
</span><span class="boring">   let u2 = TokenUsage { account: acc, tokens: 150 };
</span><span class="boring">   assert!(u1.combine(&amp;u2).is_ok());
</span><span class="boring">}</span></code></pre></pre>
<p>Now let’s look at <code>batch_generate</code>, to implement the generation of <code>n</code> completions. Unlike before, this can now be implemented in terms of <code>generate_completion</code>, as we had hoped.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(PartialEq, Clone)] struct AccountId;
</span><span class="boring">#[derive(Clone, Copy)] struct Completion { tokens: i32 }
</span><span class="boring">impl Completion { fn new() -&gt; Self { Completion { tokens: 100 } } }
</span><span class="boring">#[derive(Clone)] struct TokenUsage { account: AccountId, tokens: i32 }
</span><span class="boring">impl TokenUsage { 
</span><span class="boring">   fn new(account: AccountId, tokens: i32) -&gt; Self { TokenUsage { account, tokens } } 
</span><span class="boring">   fn combine(&amp;self, other: &amp;TokenUsage) -&gt; Result&lt;TokenUsage, String&gt; { Ok(TokenUsage { account: self.account.clone(), tokens: self.tokens + other.tokens }) }
</span><span class="boring">}
</span><span class="boring">struct LLMClient;
</span>impl LLMClient {
<span class="boring">  fn generate_completion(&amp;self, account: &amp;AccountId) -&gt; (Completion, TokenUsage) { (Completion::new(), TokenUsage::new(account.clone(), 100)) }
</span>    fn batch_generate(&amp;self, account: &amp;AccountId, n: usize) -&gt; (Vec&lt;Completion&gt;, TokenUsage) {
        let results: Vec&lt;(Completion, TokenUsage)&gt; = (0..n)
            .map(|_| self.generate_completion(account))
            .collect();
        
        let (completions, usages): (Vec&lt;Completion&gt;, Vec&lt;TokenUsage&gt;) = results.into_iter().unzip();
        
        let total_usage = usages.into_iter()
            .reduce(|u1, u2| u1.combine(&amp;u2).unwrap())
            .unwrap_or(TokenUsage::new(account.clone(), 0));
            
        (completions, total_usage)
    }
}
<span class="boring">fn main() {
</span><span class="boring">    let client = LLMClient;
</span><span class="boring">    let acc = AccountId;
</span><span class="boring">    let (_, usage) = client.batch_generate(&amp;acc, 12);
</span><span class="boring">    assert_eq!(usage.tokens, 1200);
</span><span class="boring">}</span></code></pre></pre>
<p>Overall, this solution is a marked improvement—we’re now able to reuse <code>generate_completion</code> directly to define the <code>batch_generate</code> function, and both functions are trivially testable without having to define complicated mock implementations of some <code>Billing</code> interface!</p>
<p>Making <code>TokenUsage</code> into a first-class value has other benefits we might not have anticipated: we can more easily assemble business logic for working with these usage logs. For instance, an Agent might run a complex multi-step workflow involving creating documents, researching, and coding. It might be nice if we could combine all the usage across these different tools into a single billable event. Since <code>TokenUsage</code> is first-class, we can write the following function to coalesce any same-account usage in a <code>Vec&lt;TokenUsage&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::collections::HashMap;
</span><span class="boring">#[derive(PartialEq, Eq, Clone, Hash)] struct AccountId;
</span><span class="boring">#[derive(Clone)] struct TokenUsage { account: AccountId, tokens: i32 }
</span><span class="boring">impl TokenUsage { fn combine(&amp;self, other: &amp;TokenUsage) -&gt; Result&lt;TokenUsage, String&gt; { Ok(TokenUsage { account: self.account.clone(), tokens: self.tokens + other.tokens }) } }
</span> 
fn coalesce_usage(logs: Vec&lt;TokenUsage&gt;) -&gt; Vec&lt;TokenUsage&gt; {
    // In a real Rust app, we might use itertools using a HashMap or sort first
    // Since we don't have itertools in pure std, we can implement it simply.
    
    let mut groups: HashMap&lt;AccountId, Vec&lt;TokenUsage&gt;&gt; = HashMap::new();
    for log in logs {
        groups.entry(log.account.clone()).or_default().push(log);
    }
    
    groups.values()
        .map(|list| list.iter().cloned().reduce(|u1, u2| u1.combine(&amp;u2).unwrap()).unwrap())
        .collect()
}
<span class="boring">fn main() {
</span><span class="boring">   let acc = AccountId;
</span><span class="boring">   let logs = vec![TokenUsage { account: acc.clone(), tokens: 10 }, TokenUsage { account: acc, tokens: 20 }];
</span><span class="boring">   let summary = coalesce_usage(logs);
</span><span class="boring">   assert_eq!(summary[0].tokens, 30);
</span><span class="boring">}</span></code></pre></pre>
<p>This sort of transformation can be applied to any function with side effects to push these effects to the outer layers of the program. Functional programmers often speak of implementing programs with a pure core and a thin layer on the outside that handles effects (I/O).</p>
<h2 id="12-exactly-what-is-a-pure-function"><a class="header" href="#12-exactly-what-is-a-pure-function">1.2 Exactly what is a (pure) function?</a></h2>
<p>We said earlier that FP means programming with pure functions, and a pure function is one that lacks side effects. In our discussion of the LLM example, we worked off an informal notion of side effects and purity. Here we’ll formalize this notion, to pinpoint more precisely what it means to program functionally (or "Agentically").</p>
<p>A function <code>f</code> with input type <code>A</code> and output type <code>B</code> (written in Rust as <code>fn(A) -&gt; B</code>) is a computation that relates every value <code>a</code> of type <code>A</code> to exactly one value <code>b</code> of type <code>B</code> such that <code>b</code> is determined solely by the value of <code>a</code>. Any changing state of an internal or external process is irrelevant to computing the result <code>f(a)</code>. For example, a function <code>int_to_string</code> having type <code>fn(i32) -&gt; String</code> will take every integer to a corresponding string. Furthermore, if it really is a function, it will do nothing else.</p>
<p>In other words, a function (or <strong>Deterministic Tool</strong>) has no observable effect on the execution of the program other than to compute a result given its inputs; we say that it has no side effects.</p>
<p>We can formalize this idea of pure functions using the concept of <strong>referential transparency (RT)</strong>. This is a property of expressions in general and not just functions. For the purposes of our discussion, consider an expression to be any part of a program that can be evaluated to a result. For example, <code>2 + 3</code> is an expression that applies the pure function <code>+</code> to the values <code>2</code> and <code>3</code>. This has no side effect. The evaluation of this expression results in the same value <code>5</code> every time. In fact, if we saw <code>2 + 3</code> in a program we could simply replace it with the value <code>5</code> and it wouldn’t change a thing about the meaning of our program.</p>
<p>This is all it means for an expression to be referentially transparent—in any program, the expression can be replaced by its result without changing the meaning of the program. And we say that a function is pure if calling it with RT arguments is also RT.</p>
<h2 id="13-referential-transparency-purity-and-the-substitution-model"><a class="header" href="#13-referential-transparency-purity-and-the-substitution-model">1.3 Referential transparency, purity, and the substitution model</a></h2>
<p>Let’s see how the definition of RT applies to our original <code>generate_completion</code> example:</p>
<pre><code class="language-rust ignore">fn generate_completion(&amp;self, billing: &amp;mut BillingService) -&gt; Completion {
    let response = Completion::new();
    billing.charge_usage(response.tokens);
    response
}</code></pre>
<p>Whatever the return type of <code>billing.charge_usage(...)</code> (perhaps it’s <code>()</code> unit), it’s discarded by <code>generate_completion</code>. Thus, the result of evaluating <code>generate_completion(my_account)</code> will be merely <code>response</code>. For <code>generate_completion</code> to be pure, by our definition of RT, it must be the case that <code>p(generate_completion(my_account))</code> behaves the same as <code>p(Completion::new())</code>, for any <code>p</code>.</p>
<p>This clearly doesn’t hold—the program <code>Completion::new()</code> doesn’t do anything, whereas <code>generate_completion(my_account)</code> will contact the billing system and charge real money. Already we have an observable difference between the two programs.</p>
<p>Referential transparency forces the invariant that everything a function does is represented by the value that it returns, according to the result type of the function. This constraint enables a simple and natural mode of reasoning about program evaluation called the <strong>substitution model</strong>. When expressions are referentially transparent, we can imagine that computation proceeds much like we’d solve an algebraic equation. We fully expand every part of an expression, replacing all variables with their referents, and then reduce it to its simplest form. At each step we replace a term with an equivalent one; computation proceeds by substituting equals for equals. In other words, RT enables equational reasoning about programs.</p>
<h2 id="14-summary"><a class="header" href="#14-summary">1.4 Summary</a></h2>
<p>In this chapter, we introduced functional programming and explained exactly what FP is and why you might use it. We illustrated some of the benefits of FP using a simple example. We also discussed referential transparency and the substitution model and talked about how FP enables simpler reasoning about programs and greater modularity.</p>
<p>In this book, you’ll learn the concepts and principles of FP as they apply to every level of Agentic programming, starting from the simplest of tasks and building on that foundation.</p>
<h2 id="15-references"><a class="header" href="#15-references">1.5 References</a></h2>
<ul>
<li><strong>Rust Book Ch 1 (Introduction)</strong>: <a href="https://doc.rust-lang.org/book/ch01-00-getting-started.html">The Rust Programming Language</a></li>
<li><strong>Rust By Example</strong>: <a href="https://doc.rust-lang.org/rust-by-example/index.html">Introduction</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next prefetch" href="chapter_2_getting_started.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

                    <a rel="next prefetch" href="chapter_2_getting_started.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
