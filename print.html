<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functional Programming in Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="A pedagogical guide inspired by the Red Book and Rust resources.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="chapter_1_introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="chapter_2_getting_started.html">Getting Started</a></li><li class="chapter-item expanded affix "><a href="chapter_3_functional_data_structures.html">Functional Data Structures</a></li><li class="chapter-item expanded affix "><a href="chapter_4_handling_errors.html">Handling Errors</a></li><li class="chapter-item expanded affix "><a href="chapter_5_strictness_and_laziness.html">Strictness and Laziness</a></li><li class="chapter-item expanded affix "><a href="chapter_6_purely_functional_state.html">Purely Functional State</a></li><li class="chapter-item expanded affix "><a href="chapter_7_purely_functional_parallelism.html">Purely Functional Parallelism</a></li><li class="chapter-item expanded affix "><a href="chapter_8_property_based_testing.html">Property-Based Testing</a></li><li class="chapter-item expanded affix "><a href="chapter_9_parser_combinators.html">Parser Combinators</a></li><li class="chapter-item expanded affix "><a href="chapter_10_monoids.html">Monoids</a></li><li class="chapter-item expanded affix "><a href="chapter_11_monads.html">Monads</a></li><li class="chapter-item expanded affix "><a href="chapter_12_applicative.html">Applicative and Traversable</a></li><li class="chapter-item expanded affix "><a href="chapter_13_effects.html">External Effects and I/O</a></li><li class="chapter-item expanded affix "><a href="chapter_14_local_effects.html">Local Effects and Mutable State</a></li><li class="chapter-item expanded affix "><a href="chapter_15_streaming.html">Stream Processing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Functional Programming in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-1-what-is-functional-programming"><a class="header" href="#chapter-1-what-is-functional-programming">Chapter 1: What is functional programming?</a></h1>
<p>Functional programming (FP) is based on a simple premise with far-reaching implications: we construct our programs using only pure functions—in other words, functions that have no side effects. What are side effects? A function has a side effect if it does something other than simply return a result, for example:</p>
<ul>
<li>Modifying a variable</li>
<li>Modifying a data structure in place</li>
<li>Setting a field on an object</li>
<li>Throwing an exception or halting with an error</li>
<li>Printing to the console or reading user input</li>
<li>Reading from or writing to a file</li>
<li>Drawing on the screen</li>
</ul>
<p>We’ll provide a more precise definition of side effects later in this chapter, but consider what programming would be like without the ability to do these things, or with significant restrictions on when and how these actions can occur. It may be difficult to imagine. How is it even possible to write useful programs at all? If we can’t reassign variables, how do we write simple programs like loops? What about working with data that changes, or handling errors without throwing exceptions? How can we write programs that must perform I/O, like drawing to the screen or reading from a file?</p>
<p>The answer is that functional programming is a restriction on how we write programs, but not on what programs we can express. Over the course of this book, we’ll learn how to express all of our programs without side effects, and that includes programs that perform I/O, handle errors, and modify data. We’ll learn how following the discipline of FP is tremendously beneficial because of the increase in modularity that we gain from programming with pure functions. Because of their modularity, pure functions are easier to test, reuse, parallelize, generalize, and reason about. Furthermore, pure functions are much less prone to bugs.</p>
<p>In this chapter, we’ll look at a simple program with side effects and demonstrate some of the benefits of FP by removing these side effects. We’ll also discuss the benefits of FP more generally and define two important concepts—referential transparency and the substitution model.</p>
<h2 id="11-the-benefits-of-fp-a-simple-example"><a class="header" href="#11-the-benefits-of-fp-a-simple-example">1.1 The benefits of FP: a simple example</a></h2>
<p>Let’s look at an example that demonstrates some of the benefits of programming with pure functions. The point here is just to illustrate some basic ideas that we’ll return to throughout this book. This will also be your first exposure to Rust's syntax if you are new to the language.</p>
<h3 id="111-a-program-with-side-effects"><a class="header" href="#111-a-program-with-side-effects">1.1.1 A program with side effects</a></h3>
<p>Suppose we’re implementing a program to handle purchases at a coffee shop. We’ll begin with a Rust program that uses side effects in its implementation (also called an impure program).</p>
<pre><code class="language-rust ignore">struct Cafe;

impl Cafe {
    fn buy_coffee(&amp;self, cc: &amp;mut CreditCard) -&gt; Coffee {
        let cup = Coffee::new();
        cc.charge(cup.price);
        cup
    }
}</code></pre>
<p>The line <code>cc.charge(cup.price)</code> is an example of a side effect. Charging a credit card involves some interaction with the outside world—suppose it requires contacting the credit card company via some web service, authorizing the transaction, charging the card, and (if successful) persisting some record of the transaction for later reference.</p>
<p>But our function merely returns a <code>Coffee</code> and these other actions are happening on the side, hence the term “side effect.”</p>
<p>As a result of this side effect, the code is difficult to test. We don’t want our tests to actually contact the credit card company and charge the card! This lack of testability is suggesting a design change: arguably, <code>CreditCard</code> shouldn’t have any knowledge baked into it about how to contact the credit card company to actually execute a charge, nor should it have knowledge of how to persist a record of this charge in our internal systems. We can make the code more modular and testable by letting <code>CreditCard</code> be ignorant of these concerns and passing a <code>Payments</code> object into <code>buy_coffee</code>.</p>
<pre><code class="language-rust ignore">struct Cafe;

impl Cafe {
    fn buy_coffee(&amp;self, cc: &amp;mut CreditCard, p: &amp;mut Payments) -&gt; Coffee {
        let cup = Coffee::new();
        p.charge(cc, cup.price);
        cup
    }
}</code></pre>
<p>Though side effects still occur when we call <code>p.charge(cc, cup.price)</code>, we have at least regained some testability. <code>Payments</code> can be a trait (interface), and we can write a mock implementation of this trait that is suitable for testing. But that isn’t ideal either. We’re forced to make <code>Payments</code> a trait, when a concrete struct may have been fine otherwise, and any mock implementation will be awkward to use. For example, it might contain some internal state that we’ll have to inspect after the call to <code>buy_coffee</code>, and our test will have to make sure this state has been appropriately modified (mutated) by the call to <code>charge</code>.</p>
<p>Separate from the concern of testing, there’s another problem: it’s difficult to reuse <code>buy_coffee</code>. Suppose a customer, Alice, would like to order 12 cups of coffee. Ideally we could just reuse <code>buy_coffee</code> for this, perhaps calling it 12 times in a loop. But as it is currently implemented, that will involve contacting the payment system 12 times, authorizing 12 separate charges to Alice’s credit card! That adds more processing fees and isn’t good for Alice or the coffee shop.</p>
<h3 id="112-a-functional-solution-removing-the-side-effects"><a class="header" href="#112-a-functional-solution-removing-the-side-effects">1.1.2 A functional solution: removing the side effects</a></h3>
<p>The functional solution is to eliminate side effects and have <code>buy_coffee</code> return the charge as a value in addition to returning the <code>Coffee</code>. The concerns of processing the charge by sending it off to the credit card company, persisting a record of it, and so on, will be handled elsewhere.</p>
<p>Here’s what a functional solution might look like in Rust:</p>
<pre><code class="language-rust ignore">struct Cafe;

impl Cafe {
    fn buy_coffee(&amp;self, cc: &amp;CreditCard) -&gt; (Coffee, Charge) {
        let cup = Coffee::new();
        (cup, Charge::new(cc.clone(), cup.price))
    }
}</code></pre>
<p>Here we’ve separated the concern of creating a charge from the processing or interpretation of that charge. The <code>buy_coffee</code> function now returns a <code>Charge</code> as a value along with the <code>Coffee</code>. We’ll see shortly how this lets us reuse it more easily to purchase multiple coffees with a single transaction. But what is <code>Charge</code>? It’s a data type we just invented containing a <code>CreditCard</code> and an amount, equipped with a handy function, <code>combine</code>, for combining charges with the same <code>CreditCard</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Charge {
    cc: CreditCard,
    amount: f64,
}

impl Charge {
    fn combine(&amp;self, other: &amp;Charge) -&gt; Result&lt;Charge, String&gt; {
        if self.cc == other.cc {
            Ok(Charge {
                cc: self.cc.clone(),
                amount: self.amount + other.amount,
            })
        } else {
            Err("Can't combine charges to different cards".to_string())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now let’s look at <code>buy_coffees</code>, to implement the purchase of <code>n</code> cups of coffee. Unlike before, this can now be implemented in terms of <code>buy_coffee</code>, as we had hoped.</p>
<pre><code class="language-rust ignore">impl Cafe {
    fn buy_coffees(&amp;self, cc: &amp;CreditCard, n: usize) -&gt; (Vec&lt;Coffee&gt;, Charge) {
        let purchases: Vec&lt;(Coffee, Charge)&gt; = (0..n)
            .map(|_| self.buy_coffee(cc))
            .collect();
        
        let (coffees, charges): (Vec&lt;Coffee&gt;, Vec&lt;Charge&gt;) = purchases.into_iter().unzip();
        
        let combined_charge = charges.into_iter()
            .reduce(|c1, c2| c1.combine(&amp;c2).unwrap())
            .unwrap_or(Charge::new(cc.clone(), 0.0)); // Handle 0 coffees case
            
        (coffees, combined_charge)
    }
}</code></pre>
<p>Overall, this solution is a marked improvement—we’re now able to reuse <code>buy_coffee</code> directly to define the <code>buy_coffees</code> function, and both functions are trivially testable without having to define complicated mock implementations of some <code>Payments</code> interface!</p>
<p>Making <code>Charge</code> into a first-class value has other benefits we might not have anticipated: we can more easily assemble business logic for working with these charges. For instance, Alice may bring her laptop to the coffee shop and work there for a few hours, making occasional purchases. It might be nice if the coffee shop could combine these purchases Alice makes into a single charge, again saving on credit card processing fees. Since <code>Charge</code> is first-class, we can write the following function to coalesce any same-card charges in a <code>Vec&lt;Charge&gt;</code>:</p>
<pre><code class="language-rust ignore">fn coalesce(charges: Vec&lt;Charge&gt;) -&gt; Vec&lt;Charge&gt; {
    // In a real Rust app, we might use itertools using a HashMap or sort first
    // Since we don't have itertools in pure std, we can implement it simply.
    // For brevity, let's assume we have a way to group by card:
    
    let mut groups: HashMap&lt;CreditCard, Vec&lt;Charge&gt;&gt; = HashMap::new();
    for charge in charges {
        groups.entry(charge.cc.clone()).or_default().push(charge);
    }
    
    groups.values()
        .map(|list| list.iter().cloned().reduce(|c1, c2| c1.combine(&amp;c2).unwrap()).unwrap())
        .collect()
}</code></pre>
<p>This sort of transformation can be applied to any function with side effects to push these effects to the outer layers of the program. Functional programmers often speak of implementing programs with a pure core and a thin layer on the outside that handles effects.</p>
<h2 id="12-exactly-what-is-a-pure-function"><a class="header" href="#12-exactly-what-is-a-pure-function">1.2 Exactly what is a (pure) function?</a></h2>
<p>We said earlier that FP means programming with pure functions, and a pure function is one that lacks side effects. In our discussion of the coffee shop example, we worked off an informal notion of side effects and purity. Here we’ll formalize this notion, to pinpoint more precisely what it means to program functionally.</p>
<p>A function <code>f</code> with input type <code>A</code> and output type <code>B</code> (written in Rust as <code>fn(A) -&gt; B</code>) is a computation that relates every value <code>a</code> of type <code>A</code> to exactly one value <code>b</code> of type <code>B</code> such that <code>b</code> is determined solely by the value of <code>a</code>. Any changing state of an internal or external process is irrelevant to computing the result <code>f(a)</code>. For example, a function <code>int_to_string</code> having type <code>fn(i32) -&gt; String</code> will take every integer to a corresponding string. Furthermore, if it really is a function, it will do nothing else.</p>
<p>In other words, a function has no observable effect on the execution of the program other than to compute a result given its inputs; we say that it has no side effects.</p>
<p>We can formalize this idea of pure functions using the concept of <strong>referential transparency (RT)</strong>. This is a property of expressions in general and not just functions. For the purposes of our discussion, consider an expression to be any part of a program that can be evaluated to a result. For example, <code>2 + 3</code> is an expression that applies the pure function <code>+</code> to the values <code>2</code> and <code>3</code>. This has no side effect. The evaluation of this expression results in the same value <code>5</code> every time. In fact, if we saw <code>2 + 3</code> in a program we could simply replace it with the value <code>5</code> and it wouldn’t change a thing about the meaning of our program.</p>
<p>This is all it means for an expression to be referentially transparent—in any program, the expression can be replaced by its result without changing the meaning of the program. And we say that a function is pure if calling it with RT arguments is also RT.</p>
<h2 id="13-referential-transparency-purity-and-the-substitution-model"><a class="header" href="#13-referential-transparency-purity-and-the-substitution-model">1.3 Referential transparency, purity, and the substitution model</a></h2>
<p>Let’s see how the definition of RT applies to our original <code>buy_coffee</code> example:</p>
<pre><code class="language-rust ignore">fn buy_coffee(&amp;self, cc: &amp;mut CreditCard) -&gt; Coffee {
    let cup = Coffee::new();
    cc.charge(cup.price);
    cup
}</code></pre>
<p>Whatever the return type of <code>cc.charge(cup.price)</code> (perhaps it’s <code>()</code> unit), it’s discarded by <code>buy_coffee</code>. Thus, the result of evaluating <code>buy_coffee(alice_credit_card)</code> will be merely <code>cup</code>, which is equivalent to a <code>Coffee::new()</code>. For <code>buy_coffee</code> to be pure, by our definition of RT, it must be the case that <code>p(buy_coffee(alice_credit_card))</code> behaves the same as <code>p(Coffee::new())</code>, for any <code>p</code>.</p>
<p>This clearly doesn’t hold—the program <code>Coffee::new()</code> doesn’t do anything, whereas <code>buy_coffee(alice_credit_card)</code> will contact the credit card company and authorize a charge. Already we have an observable difference between the two programs.</p>
<p>Referential transparency forces the invariant that everything a function does is represented by the value that it returns, according to the result type of the function. This constraint enables a simple and natural mode of reasoning about program evaluation called the <strong>substitution model</strong>. When expressions are referentially transparent, we can imagine that computation proceeds much like we’d solve an algebraic equation. We fully expand every part of an expression, replacing all variables with their referents, and then reduce it to its simplest form. At each step we replace a term with an equivalent one; computation proceeds by substituting equals for equals. In other words, RT enables equational reasoning about programs.</p>
<h2 id="14-summary"><a class="header" href="#14-summary">1.4 Summary</a></h2>
<p>In this chapter, we introduced functional programming and explained exactly what FP is and why you might use it. We illustrated some of the benefits of FP using a simple example. We also discussed referential transparency and the substitution model and talked about how FP enables simpler reasoning about programs and greater modularity.</p>
<p>In this book, you’ll learn the concepts and principles of FP as they apply to every level of programming, starting from the simplest of tasks and building on that foundation.</p>
<h2 id="15-references"><a class="header" href="#15-references">1.5 References</a></h2>
<ul>
<li><strong>Rust Book Ch 1 (Introduction)</strong>: <a href="https://doc.rust-lang.org/book/ch01-00-getting-started.html">The Rust Programming Language</a></li>
<li><strong>Rust By Example</strong>: <a href="https://doc.rust-lang.org/rust-by-example/index.html">Introduction</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-getting-started-with-functional-programming-in-rust"><a class="header" href="#chapter-2-getting-started-with-functional-programming-in-rust">Chapter 2: Getting started with functional programming in Rust</a></h1>
<p>In this chapter, we’ll begin learning how to write programs in the Rust language just by combining pure functions. This chapter is mainly intended for those readers who are new to Rust, to functional programming, or both.</p>
<h2 id="21-introducing-rust-an-example"><a class="header" href="#21-introducing-rust-an-example">2.1 Introducing Rust: an example</a></h2>
<p>The following is a complete program listing in Rust. Our goal is just to introduce the Rust language and its syntax.</p>
<pre><pre class="playground"><code class="language-rust">// A comment!
/* Another comment */
/// A documentation comment

pub mod my_module {
    pub fn abs(n: i32) -&gt; i32 {
        if n &lt; 0 {
            -n
        } else {
            n
        }
    }

    fn format_abs(x: i32) -&gt; String {
        let msg = "The absolute value of {} is {}";
        format!(msg, x, abs(x))
    }

    pub fn main() {
        println!("{}", format_abs(-42));
    }
}</code></pre></pre>
<p>We declare a module <code>my_module</code>. This is simply to give our code a place to live. Rust code is organized into modules (<code>mod</code>) and creates (structs, enums).</p>
<p>The <code>abs</code> function is a pure function that takes an integer and returns its absolute value. Note the absence of an explicit <code>return</code> keyword. The value returned from a function is simply whatever value results from evaluating the last expression in the block.</p>
<h2 id="22-running-our-program"><a class="header" href="#22-running-our-program">2.2 Running our program</a></h2>
<p>The simplest way to run this is using <code>cargo</code>. If this were in <code>src/main.rs</code>, you could run:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<h2 id="23-higher-order-functions-passing-functions-to-functions"><a class="header" href="#23-higher-order-functions-passing-functions-to-functions">2.3 Higher-order functions: passing functions to functions</a></h2>
<p>Functions are values. They can be assigned to variables, stored in data structures, and passed as arguments to functions.</p>
<h3 id="231-a-short-detour-writing-loops-functionally"><a class="header" href="#231-a-short-detour-writing-loops-functionally">2.3.1 A short detour: writing loops functionally</a></h3>
<p>First, let’s write <code>factorial</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn factorial(n: i32) -&gt; i32 {
    fn go(n: i32, acc: i32) -&gt; i32 {
        if n &lt;= 0 {
            acc
        } else {
            go(n - 1, n * acc)
        }
    }
    go(n, 1)
}
<span class="boring">}</span></code></pre></pre>
<p>The way we write loops functionally, without mutating a loop variable, is with a recursive function. Rust supports recursion, though it does not guarantee <strong>tail call elimination</strong> (TCO) in the same way Scala or Scheme might. For deep recursion, Rust programmers often use <code>loop</code>, <code>while</code>, or iterators to avoid blowing the stack. However, for the sake of learning FP concepts, we will use recursion here.</p>
<h3 id="exercise-21"><a class="header" href="#exercise-21">Exercise 2.1</a></h3>
<p>Write a recursive function to get the <code>n</code>th Fibonacci number. The first two Fibonacci numbers are 0 and 1. The <code>n</code>th number is always the sum of the previous two.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fib(n: u32) -&gt; u32 {
    fn go(n: u32, prev: u32, curr: u32) -&gt; u32 {
        if n == 0 {
            prev
        } else {
            go(n - 1, curr, prev + curr)
        }
    }
    go(n, 0, 1)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="232-writing-our-first-higher-order-function"><a class="header" href="#232-writing-our-first-higher-order-function">2.3.2 Writing our first higher-order function</a></h3>
<p>We can generalize <code>format_abs</code> and <code>format_factorial</code> to a single function <code>format_result</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn format_result(name: &amp;str, n: i32, f: fn(i32) -&gt; i32) -&gt; String {
    format!("The {} of {} is {}.", name, n, f(n))
}
<span class="boring">}</span></code></pre></pre>
<p><code>f</code> is a function pointer or closure trait. Here we use <code>fn(i32) -&gt; i32</code>, which is a function pointer.</p>
<h2 id="24-polymorphic-functions-abstracting-over-types"><a class="header" href="#24-polymorphic-functions-abstracting-over-types">2.4 Polymorphic functions: abstracting over types</a></h2>
<p>We can write functions that work for any type.</p>
<h3 id="241-an-example-of-a-polymorphic-function"><a class="header" href="#241-an-example-of-a-polymorphic-function">2.4.1 An example of a polymorphic function</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn find_first&lt;A, F&gt;(as_slice: &amp;[A], p: F) -&gt; Option&lt;usize&gt; 
where F: Fn(&amp;A) -&gt; bool {
    let mut n = 0;
    while n &lt; as_slice.len() {
        if p(&amp;as_slice[n]) {
            return Some(n);
        }
        n += 1;
    }
    None
}
<span class="boring">}</span></code></pre></pre>
<p>Here, <code>A</code> is a generic type parameter. <code>F</code> is a generic type bounded by the <code>Fn</code> trait.</p>
<h3 id="exercise-22"><a class="header" href="#exercise-22">Exercise 2.2</a></h3>
<p>Implement <code>is_sorted</code>, which checks whether a slice <code>&amp;[A]</code> is sorted according to a given comparison function.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_sorted&lt;A, F&gt;(as_slice: &amp;[A], ordered: F) -&gt; bool 
where F: Fn(&amp;A, &amp;A) -&gt; bool {
    let mut n = 0;
    while n + 1 &lt; as_slice.len() {
        if !ordered(&amp;as_slice[n], &amp;as_slice[n+1]) {
            return false;
        }
        n += 1;
    }
    true
}
<span class="boring">}</span></code></pre></pre>
<h2 id="25-following-types-to-implementations"><a class="header" href="#25-following-types-to-implementations">2.5 Following types to implementations</a></h2>
<h3 id="exercise-23-currying"><a class="header" href="#exercise-23-currying">Exercise 2.3 (Currying)</a></h3>
<p>Currying converts a function <code>f</code> of two arguments into a function of one argument that partially applies <code>f</code>.
Note: In Rust, returning closures involving references or generics can be complex due to lifetimes. We use <code>impl Fn</code> (existential type) to return a closure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn curry&lt;A, B, C, F&gt;(f: F) -&gt; impl Fn(A) -&gt; Box&lt;dyn Fn(B) -&gt; C&gt;
where
    A: 'static + Clone,
    B: 'static,
    C: 'static,
    F: Fn(A, B) -&gt; C + 'static + Clone,
{
    move |a: A| {
        let f = f.clone();
        Box::new(move |b: B| f(a.clone(), b))
    }
}
<span class="boring">}</span></code></pre></pre>
<p><em>Note: This strictly follows the type signature but requires allocation (<code>Box</code>) and cloning to satisfy the borrow checker for arbitrary <code>A</code>, <code>B</code>. In idiomatic Rust, we rarely "curry" manually, but the concept stands.</em></p>
<h3 id="exercise-24-uncurry"><a class="header" href="#exercise-24-uncurry">Exercise 2.4 (Uncurry)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn uncurry&lt;A, B, C, F&gt;(f: F) -&gt; impl Fn(A, B) -&gt; C
where
    F: Fn(A) -&gt; Box&lt;dyn Fn(B) -&gt; C&gt; + 'static,
{
    move |a: A, b: B| {
        let g = f(a);
        g(b)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-25-compose"><a class="header" href="#exercise-25-compose">Exercise 2.5 (Compose)</a></h3>
<p>Implement the higher-order function that composes two functions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compose&lt;A, B, C, F, G&gt;(f: F, g: G) -&gt; impl Fn(A) -&gt; C
where
    F: Fn(B) -&gt; C + 'static,
    G: Fn(A) -&gt; B + 'static,
    A: 'static,
{
    move |a: A| f(g(a))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="26-summary"><a class="header" href="#26-summary">2.6 Summary</a></h2>
<p>We introduced Rust syntax, recursion, higher-order functions (HOFs), and polymorphism.</p>
<h2 id="27-references"><a class="header" href="#27-references">2.7 References</a></h2>
<ul>
<li><strong>Functions</strong>: <a href="https://doc.rust-lang.org/book/ch03-03-how-functions-work.html">The Rust Book Ch 3.3</a></li>
<li><strong>Generics (<code>&lt;T&gt;</code>)</strong>: <a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">The Rust Book Ch 10.1</a></li>
<li><strong>Trait Bounds (<code>where F: Fn</code>)</strong>: <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">The Rust Book Ch 10.2</a></li>
<li><strong>Closures &amp; Iterators</strong>: <a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">The Rust Book Ch 13</a></li>
<li><strong>Rust By Example (Functions)</strong>: <a href="https://doc.rust-lang.org/rust-by-example/fn.html">Functions</a></li>
<li><strong>Rust By Example (Closures)</strong>: <a href="https://doc.rust-lang.org/rust-by-example/fn/closures.html">Closures</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-functional-data-structures"><a class="header" href="#chapter-3-functional-data-structures">Chapter 3: Functional data structures</a></h1>
<p>In this chapter, we’ll learn the concept of functional data structures and how to work with them. We’ll use this as an opportunity to introduce how data types are defined in functional programming, learn about the related technique of pattern matching, and get practice writing and generalizing pure functions.</p>
<h2 id="31-defining-functional-data-structures"><a class="header" href="#31-defining-functional-data-structures">3.1 Defining functional data structures</a></h2>
<p>A functional data structure is operated on using only pure functions. Functional data structures are by definition immutable.</p>
<p>In Rust, the most ubiquitous functional data structure, the singly linked list, can be defined using an <code>enum</code>. To enable <strong>data sharing</strong> (persistence) as described in functional literature, we use <code>Rc</code> (Reference Counting) instead of <code>Box</code> (unique ownership). This allows multiple lists to share the same tail segments.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

#[derive(Clone, Debug)]
pub enum List&lt;A&gt; {
    Nil,
    Cons(A, Rc&lt;List&lt;A&gt;&gt;),
}

use List::*;

impl&lt;A&gt; Default for List&lt;A&gt; {
    fn default() -&gt; Self {
        Nil
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Let’s look at the definition. <code>enum List</code> has two variants: <code>Nil</code> (empty) and <code>Cons</code> (non-empty). <code>Cons</code> holds a value of type <code>A</code> and a reference-counted pointer <code>Rc</code> to the rest of the list.</p>
<h3 id="data-sharing"><a class="header" href="#data-sharing">Data Sharing</a></h3>
<p>When we add an element <code>1</code> to the front of an existing list <code>xs</code>, we return a new list <code>Cons(1, Rc::new(xs))</code>. We don't copy <code>xs</code>; we just reuse it. This is called data sharing. Functional data structures are <strong>persistent</strong>, meaning existing references are never changed by operations.</p>
<h2 id="32-pattern-matching"><a class="header" href="#32-pattern-matching">3.2 Pattern matching</a></h2>
<p>Rust supports pattern matching via <code>match</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sum(ints: &amp;List&lt;i32&gt;) -&gt; i32 {
    match ints {
        Nil =&gt; 0,
        Cons(x, xs) =&gt; x + sum(xs),
    }
}

pub fn product(ds: &amp;List&lt;f64&gt;) -&gt; f64 {
    match ds {
        Nil =&gt; 1.0,
        Cons(0.0, _) =&gt; 0.0,
        Cons(x, xs) =&gt; x * product(xs),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-31"><a class="header" href="#exercise-31">Exercise 3.1</a></h3>
<p>What will be the result of the match expression?
<em>Answer: The match expression in the book (translated to Rust syntax) would match the third case <code>x + y</code>, resulting in 3 (1 + 2).</em></p>
<h2 id="33-data-sharing-in-functional-data-structures"><a class="header" href="#33-data-sharing-in-functional-data-structures">3.3 Data sharing in functional data structures</a></h2>
<h3 id="exercise-32-tail"><a class="header" href="#exercise-32-tail">Exercise 3.2: Tail</a></h3>
<p>Implement the function <code>tail</code> for removing the first element of a List. Note that the function takes constant time.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn tail&lt;A&gt;(l: &amp;List&lt;A&gt;) -&gt; Option&lt;&amp;Rc&lt;List&lt;A&gt;&gt;&gt; {
    match l {
        Nil =&gt; None,
        Cons(_, xs) =&gt; Some(xs),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><em>Note: In Rust, returning a reference to the tail <code>&amp;Rc</code> works if we borrow the input. To return an owned persistent list, we would return <code>Rc&lt;List&lt;A&gt;&gt;</code> by cloning the pointer (cheap).</em></p>
<h3 id="exercise-33-set-head"><a class="header" href="#exercise-33-set-head">Exercise 3.3: Set Head</a></h3>
<p>Implement <code>set_head</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn set_head&lt;A&gt;(l: &amp;List&lt;A&gt;, h: A) -&gt; List&lt;A&gt; 
where A: Clone {
    match l {
        Nil =&gt; panic!("set_head on empty list"), // Or return Result
        Cons(_, xs) =&gt; Cons(h, xs.clone()),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-34-drop"><a class="header" href="#exercise-34-drop">Exercise 3.4: Drop</a></h3>
<p>Generalize <code>tail</code> to <code>drop</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn drop&lt;A&gt;(l: &amp;List&lt;A&gt;, n: usize) -&gt; &amp;List&lt;A&gt; {
    if n == 0 {
        return l;
    }
    match l {
        Nil =&gt; &amp;Nil,
        Cons(_, xs) =&gt; drop(xs, n - 1),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-35-dropwhile"><a class="header" href="#exercise-35-dropwhile">Exercise 3.5: DropWhile</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn drop_while&lt;A, F&gt;(l: &amp;List&lt;A&gt;, f: F) -&gt; &amp;List&lt;A&gt; 
where F: Fn(&amp;A) -&gt; bool {
    match l {
        Cons(h, t) if f(h) =&gt; drop_while(t, f),
        _ =&gt; l,
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-36-init"><a class="header" href="#exercise-36-init">Exercise 3.6: Init</a></h3>
<p>Implement a function <code>init</code> that returns a List consisting of all but the last element.
<em>Why can't this be constant time? Because we must rebuild the path to the new end.</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn init&lt;A: Clone&gt;(l: &amp;List&lt;A&gt;) -&gt; List&lt;A&gt; {
    match l {
        Nil =&gt; panic!("init of empty list"),
        Cons(_, xs) if matches!(**xs, Nil) =&gt; Nil,
        Cons(h, xs) =&gt; Cons(h.clone(), Rc::new(init(xs))),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="34-recursion-over-lists-and-generalizing-to-higher-order-functions"><a class="header" href="#34-recursion-over-lists-and-generalizing-to-higher-order-functions">3.4 Recursion over lists and generalizing to higher-order functions</a></h2>
<h3 id="exercise-37---315-folds"><a class="header" href="#exercise-37---315-folds">Exercise 3.7 - 3.15: Folds</a></h3>
<p><strong>Exercise 3.9: Length using fold_right</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn length&lt;A&gt;(l: &amp;List&lt;A&gt;) -&gt; usize {
    fold_right(l, 0, |_, acc| acc + 1)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Exercise 3.10: Fold Left (Tail recursive)</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fold_left&lt;A, B, F&gt;(l: &amp;List&lt;A&gt;, z: B, f: F) -&gt; B 
where F: Fn(B, &amp;A) -&gt; B {
    match l {
        Nil =&gt; z,
        Cons(h, t) =&gt; fold_left(t, f(z, h), f),
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Exercise 3.12: Reverse</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn reverse&lt;A: Clone&gt;(l: &amp;List&lt;A&gt;) -&gt; List&lt;A&gt; {
    fold_left(l, Nil, |acc, h| Cons(h.clone(), Rc::new(acc)))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="35-trees"><a class="header" href="#35-trees">3.5 Trees</a></h2>
<p>Algebraic data types can be used to define other data structures.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Tree&lt;A&gt; {
    Leaf(A),
    Branch(Box&lt;Tree&lt;A&gt;&gt;, Box&lt;Tree&lt;A&gt;&gt;),
}
<span class="boring">}</span></code></pre></pre>
<p><em>Note: For Trees, <code>Box</code> (unique ownership) is often sufficient unless we need DAGs or explicit sharing.</em></p>
<h3 id="exercise-325-size"><a class="header" href="#exercise-325-size">Exercise 3.25: Size</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn size&lt;A&gt;(t: &amp;Tree&lt;A&gt;) -&gt; usize {
    match t {
        Tree::Leaf(_) =&gt; 1,
        Tree::Branch(l, r) =&gt; 1 + size(l) + size(r),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-326-maximum"><a class="header" href="#exercise-326-maximum">Exercise 3.26: Maximum</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn maximum(t: &amp;Tree&lt;i32&gt;) -&gt; i32 {
    match t {
        Tree::Leaf(v) =&gt; *v,
        Tree::Branch(l, r) =&gt; maximum(l).max(maximum(r)),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-328-map"><a class="header" href="#exercise-328-map">Exercise 3.28: Map</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn map&lt;A, B, F&gt;(t: &amp;Tree&lt;A&gt;, f: &amp;F) -&gt; Tree&lt;B&gt;
where F: Fn(&amp;A) -&gt; B {
    match t {
        Tree::Leaf(v) =&gt; Tree::Leaf(f(v)),
        Tree::Branch(l, r) =&gt; Tree::Branch(Box::new(map(l, f)), Box::new(map(r, f))),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="36-summary"><a class="header" href="#36-summary">3.6 Summary</a></h2>
<p>We introduced algebraic data types (ADTs), <code>List</code> and <code>Tree</code>, and higher-order functions like <code>map</code>, <code>fold</code>, and <code>filter</code>.</p>
<h2 id="37-references"><a class="header" href="#37-references">3.7 References</a></h2>
<ul>
<li><strong>Rust Book Ch 6 (Enums)</strong>: <a href="https://doc.rust-lang.org/book/ch06-00-enums.html">The Rust Programming Language</a></li>
<li><strong>Rust Book Ch 15 (Smart Pointers/Box)</strong>: <a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html">The Rust Programming Language</a></li>
<li><strong>Rust By Example (Enums)</strong>: <a href="https://doc.rust-lang.org/rust-by-example/custom_types/enum.html">Custom Types</a></li>
<li><strong>Rust By Example (LinkedList)</strong>: <a href="https://doc.rust-lang.org/rust-by-example/custom_types/enum/testcase_linked_list.html">Testcase: Linked List</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4-handling-errors-without-exceptions"><a class="header" href="#chapter-4-handling-errors-without-exceptions">Chapter 4: Handling errors without exceptions</a></h1>
<p>Throwing exceptions is a side effect. In functional programming, we prefer to representing failures and exceptions with ordinary values. This preserves referential transparency.</p>
<p>In this chapter, we re-create two standard library types: <code>Option</code> and <code>Either</code>.</p>
<h2 id="41-the-option-data-type"><a class="header" href="#41-the-option-data-type">4.1 The Option data type</a></h2>
<p>We represent the possibility of an undefined result with <code>Option</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Option&lt;A&gt; {
    Some(A),
    None,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercises-41-basic-functions"><a class="header" href="#exercises-41-basic-functions">Exercises 4.1: Basic Functions</a></h3>
<p>Implement <code>map</code>, <code>flat_map</code>, <code>get_or_else</code>, <code>or_else</code>, and <code>filter</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;A&gt; Option&lt;A&gt; {
    pub fn map&lt;B, F&gt;(self, f: F) -&gt; Option&lt;B&gt; 
    where F: FnOnce(A) -&gt; B {
        match self {
            Option::Some(a) =&gt; Option::Some(f(a)),
            Option::None =&gt; Option::None,
        }
    }

    pub fn flat_map&lt;B, F&gt;(self, f: F) -&gt; Option&lt;B&gt;
    where F: FnOnce(A) -&gt; Option&lt;B&gt; {
        match self {
            Option::Some(a) =&gt; f(a),
            Option::None =&gt; Option::None,
        }
    }

    pub fn get_or_else(self, default: A) -&gt; A {
        match self {
            Option::Some(a) =&gt; a,
            Option::None =&gt; default,
        }
    }

    pub fn or_else&lt;F&gt;(self, ob: F) -&gt; Option&lt;A&gt;
    where F: FnOnce() -&gt; Option&lt;A&gt; {
        match self {
            Option::Some(_) =&gt; self,
            Option::None =&gt; ob(),
        }
    }

    pub fn filter&lt;F&gt;(self, f: F) -&gt; Option&lt;A&gt;
    where F: FnOnce(&amp;A) -&gt; bool {
        match self {
            Option::Some(a) if f(&amp;a) =&gt; Option::Some(a),
            _ =&gt; Option::None,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-42-variance"><a class="header" href="#exercise-42-variance">Exercise 4.2: Variance</a></h3>
<p>Implement <code>variance</code> in terms of <code>flat_map</code>.
Variance is the mean of <code>math.pow(x - m, 2)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mean(xs: &amp;[f64]) -&gt; Option&lt;f64&gt; {
    if xs.is_empty() {
        Option::None
    } else {
        Option::Some(xs.iter().sum::&lt;f64&gt;() / xs.len() as f64)
    }
}

pub fn variance(xs: &amp;[f64]) -&gt; Option&lt;f64&gt; {
    mean(xs).flat_map(|m| mean(&amp;xs.iter().map(|x| (x - m).powi(2)).collect::&lt;Vec&lt;_&gt;&gt;()))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-43-map2"><a class="header" href="#exercise-43-map2">Exercise 4.3: Map2</a></h3>
<p>Combine two Option values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn map2&lt;A, B, C, F&gt;(a: Option&lt;A&gt;, b: Option&lt;B&gt;, f: F) -&gt; Option&lt;C&gt;
where F: FnOnce(A, B) -&gt; C {
    a.flat_map(|aa| b.map(|bb| f(aa, bb)))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-44-sequence"><a class="header" href="#exercise-44-sequence">Exercise 4.4: Sequence</a></h3>
<p>Combine a list of Options into one Option containing a list.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sequence&lt;A&gt;(a: Vec&lt;Option&lt;A&gt;&gt;) -&gt; Option&lt;Vec&lt;A&gt;&gt; {
    let mut res = Vec::new();
    for opt in a {
        match opt {
            Option::Some(val) =&gt; res.push(val),
            Option::None =&gt; return Option::None,
        }
    }
    Option::Some(res)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-45-traverse"><a class="header" href="#exercise-45-traverse">Exercise 4.5: Traverse</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn traverse&lt;A, B, F&gt;(a: Vec&lt;A&gt;, f: F) -&gt; Option&lt;Vec&lt;B&gt;&gt;
where F: Fn(A) -&gt; Option&lt;B&gt; {
    let mut res = Vec::new();
    for x in a {
        match f(x) {
            Option::Some(y) =&gt; res.push(y),
            Option::None =&gt; return Option::None,
        }
    }
    Option::Some(res)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="44-the-either-data-type"><a class="header" href="#44-the-either-data-type">4.4 The Either data type</a></h2>
<p><code>Option</code> doesn't tell us <em>why</em> something failed. <code>Either</code> lets us track a reason.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Either&lt;E, A&gt; {
    Left(E),
    Right(A),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-46-basic-functions-on-either"><a class="header" href="#exercise-46-basic-functions-on-either">Exercise 4.6: Basic Functions on Either</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;E, A&gt; Either&lt;E, A&gt; {
    pub fn map&lt;B, F&gt;(self, f: F) -&gt; Either&lt;E, B&gt;
    where F: FnOnce(A) -&gt; B {
        match self {
            Either::Right(a) =&gt; Either::Right(f(a)),
            Either::Left(e) =&gt; Either::Left(e),
        }
    }
    
    pub fn flat_map&lt;EE, B, F&gt;(self, f: F) -&gt; Either&lt;EE, B&gt;
    where 
        F: FnOnce(A) -&gt; Either&lt;EE, B&gt;,
        EE: From&lt;E&gt; 
    {
        match self {
            Either::Right(a) =&gt; f(a),
            Either::Left(e) =&gt; Either::Left(EE::from(e)),
        }
    }
    
    pub fn or_else&lt;EE, F&gt;(self, b: F) -&gt; Either&lt;EE, A&gt;
    where 
        F: FnOnce() -&gt; Either&lt;EE, A&gt;,
        EE: From&lt;E&gt;
    {
        match self {
            Either::Right(a) =&gt; Either::Right(a),
            Either::Left(_) =&gt; b(),
        }
    }
    
    pub fn map2&lt;EE, B, C, F&gt;(self, b: Either&lt;EE, B&gt;, f: F) -&gt; Either&lt;EE, C&gt;
    where 
        F: FnOnce(A, B) -&gt; C,
        EE: From&lt;E&gt; 
    {
        self.flat_map(|aa| b.map(|bb| f(aa, bb)))
    }
}
<span class="boring">}</span></code></pre></pre>
<p><em>Note: In Rust, handling different error types <code>E</code> and <code>EE</code> usually requires <code>From</code> or a common Error trait.</em></p>
<h3 id="exercise-47-sequence-and-traverse-for-either"><a class="header" href="#exercise-47-sequence-and-traverse-for-either">Exercise 4.7: Sequence and Traverse for Either</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sequence_either&lt;E, A&gt;(es: Vec&lt;Either&lt;E, A&gt;&gt;) -&gt; Either&lt;E, Vec&lt;A&gt;&gt; {
    traverse_either(es, |x| x)
}

pub fn traverse_either&lt;E, A, B, F&gt;(as_vec: Vec&lt;A&gt;, f: F) -&gt; Either&lt;E, Vec&lt;B&gt;&gt;
where F: Fn(A) -&gt; Either&lt;E, B&gt; {
    let mut res = Vec::new();
    for a in as_vec {
        match f(a) {
            Either::Right(b) =&gt; res.push(b),
            Either::Left(e) =&gt; return Either::Left(e),
        }
    }
    Either::Right(res)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-48-accumulating-errors"><a class="header" href="#exercise-48-accumulating-errors">Exercise 4.8: Accumulating Errors</a></h3>
<p>To report <em>both</em> errors in <code>mkPerson</code> (name and age invalid), we would need a data structure that can hold multiple errors, like <code>Validation&lt;Vec&lt;E&gt;, A&gt;</code>. <code>Either</code> stops at the first error (fail-fast).</p>
<h2 id="45-summary"><a class="header" href="#45-summary">4.5 Summary</a></h2>
<p>We learned to handle errors as values using <code>Option</code> and <code>Either</code>.</p>
<h2 id="46-references"><a class="header" href="#46-references">4.6 References</a></h2>
<ul>
<li><strong>Error Handling</strong>: <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">The Rust Book Ch 9</a></li>
<li><strong>Recoverable Errors (Result)</strong>: <a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">The Rust Book Ch 9.2</a></li>
<li><strong>The Option Enum</strong>: <a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html?highlight=Option#the-option-enum-and-its-advantages-over-null-values">The Rust Book Ch 6.1</a></li>
<li><strong>Rust By Example (Error Handling)</strong>: <a href="https://doc.rust-lang.org/rust-by-example/error.html">Error Handling</a></li>
<li><strong>Rust Pattern (Result/Option)</strong>: <a href="https://rust-unofficial.github.io/patterns/idioms/error-handling.html">Idioms</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-5-strictness-and-laziness"><a class="header" href="#chapter-5-strictness-and-laziness">Chapter 5: Strictness and Laziness</a></h1>
<p>In this chapter, we explore <strong>non-strictness</strong> (laziness) to improve efficiency and modularity. We implement a <code>Stream</code> type that fuses sequences of transformations.</p>
<h2 id="51-strict-and-non-strict-functions"><a class="header" href="#51-strict-and-non-strict-functions">5.1 Strict and non-strict functions</a></h2>
<p>Strict functions evaluate their arguments <em>before</em> the function body is executed. Non-strict functions may choose not to evaluate arguments.</p>
<p>In Rust, arguments are strictly evaluated by default. To simulate non-strictness, we can pass a closure (thunk) <code>Fn() -&gt; A</code> instead of a value <code>A</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// logical AND is non-strict in the second argument
// false &amp;&amp; { println!("!!"); true } // does not print
<span class="boring">}</span></code></pre></pre>
<h2 id="52-an-extended-example-lazy-lists"><a class="header" href="#52-an-extended-example-lazy-lists">5.2 An extended example: lazy lists</a></h2>
<p>We define a <code>Stream</code> (lazy list). In Scala, <code>Cons</code> takes by-name arguments. In Rust, we use closures wrapped in <code>Rc</code> (for sharing) to represent these thunks.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

#[derive(Clone)]
pub enum Stream&lt;A&gt; {
    Empty,
    Cons(Rc&lt;dyn Fn() -&gt; A&gt;, Rc&lt;dyn Fn() -&gt; Stream&lt;A&gt;&gt;),
}
// Note: We avoid memoization complexity for this basic translation. 
// In a production Rust persistent stream, one might use `lazy_static` or `OnceCell` inside `Rc`.
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-51-to_list"><a class="header" href="#exercise-51-to_list">Exercise 5.1: to_list</a></h3>
<p>Force the stream into a strict <code>List</code> (or <code>Vec</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// impl Stream&lt;A&gt;
pub fn to_vec(&amp;self) -&gt; Vec&lt;A&gt; {
    match self {
        Stream::Empty =&gt; Vec::new(),
        Stream::Cons(h, t) =&gt; {
            let mut v = vec![h()];
            v.extend(t().to_vec());
            v
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-52-take-and-drop"><a class="header" href="#exercise-52-take-and-drop">Exercise 5.2: take and drop</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn take(&amp;self, n: usize) -&gt; Stream&lt;A&gt; {
    if n == 0 {
        Stream::Empty
    } else {
        match self {
            Stream::Empty =&gt; Stream::Empty,
            Stream::Cons(h, t) =&gt; {
                let h = h.clone();
                let t = t.clone();
                Stream::cons(move || h(), move || t().take(n - 1))
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-53-take_while"><a class="header" href="#exercise-53-take_while">Exercise 5.3: take_while</a></h3>
<p>Return all starting elements that match a predicate.</p>
<h2 id="53-separating-program-description-from-evaluation"><a class="header" href="#53-separating-program-description-from-evaluation">5.3 Separating program description from evaluation</a></h2>
<p>Laziness lets us separate the description of an expression from its evaluation.</p>
<h3 id="exercise-54-for_all"><a class="header" href="#exercise-54-for_all">Exercise 5.4: for_all</a></h3>
<p>Check that all elements in the Stream match a given predicate, terminating early if possible.</p>
<h3 id="exercise-55-take_while-using-fold_right"><a class="header" href="#exercise-55-take_while-using-fold_right">Exercise 5.5: take_while using fold_right</a></h3>
<h3 id="exercise-56-head_option-using-fold_right"><a class="header" href="#exercise-56-head_option-using-fold_right">Exercise 5.6: head_option using fold_right</a></h3>
<h3 id="exercise-57-map-filter-append-flat_map-using-fold_right"><a class="header" href="#exercise-57-map-filter-append-flat_map-using-fold_right">Exercise 5.7: map, filter, append, flat_map using fold_right</a></h3>
<h2 id="54-infinite-streams-and-corecursion"><a class="header" href="#54-infinite-streams-and-corecursion">5.4 Infinite streams and corecursion</a></h2>
<p>Because functions are incremental, they work for infinite streams.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ones() -&gt; Stream&lt;i32&gt; {
    Stream::cons(|| 1, ones)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-58-constant"><a class="header" href="#exercise-58-constant">Exercise 5.8: constant</a></h3>
<h3 id="exercise-59-from"><a class="header" href="#exercise-59-from">Exercise 5.9: from</a></h3>
<h3 id="exercise-510-fibs"><a class="header" href="#exercise-510-fibs">Exercise 5.10: fibs</a></h3>
<h3 id="exercise-511-unfold"><a class="header" href="#exercise-511-unfold">Exercise 5.11: unfold</a></h3>
<p>A general stream-building function (corecursion).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn unfold&lt;A, S, F&gt;(z: S, f: F) -&gt; Stream&lt;A&gt;
where F: Fn(S) -&gt; Option&lt;(A, S)&gt; + 'static + Clone {
    match f(z) {
        Some((a, s)) =&gt; {
            let f = f.clone();
            Stream::cons(move || a.clone(), move || unfold(s, f.clone()))
        },
        None =&gt; Stream::Empty,
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-512-fibs-from-constant-ones-via-unfold"><a class="header" href="#exercise-512-fibs-from-constant-ones-via-unfold">Exercise 5.12: fibs, from, constant, ones via unfold</a></h3>
<h3 id="exercise-513-map-take-take_while-zip_with-zip_all-via-unfold"><a class="header" href="#exercise-513-map-take-take_while-zip_with-zip_all-via-unfold">Exercise 5.13: map, take, take_while, zip_with, zip_all via unfold</a></h3>
<h3 id="exercise-514-starts_with"><a class="header" href="#exercise-514-starts_with">Exercise 5.14: starts_with</a></h3>
<h3 id="exercise-515-tails"><a class="header" href="#exercise-515-tails">Exercise 5.15: tails</a></h3>
<h3 id="exercise-516-scan_right"><a class="header" href="#exercise-516-scan_right">Exercise 5.16: scan_right</a></h3>
<h2 id="55-summary"><a class="header" href="#55-summary">5.5 Summary</a></h2>
<p>Laziness improves modularity by decoupling description from evaluation.</p>
<h2 id="56-references"><a class="header" href="#56-references">5.6 References</a></h2>
<ul>
<li><strong>Rust Book Ch 13 (Iterators)</strong>: <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">The Rust Programming Language</a></li>
<li><strong>Rust By Example (Iterators)</strong>: <a href="https://doc.rust-lang.org/rust-by-example/trait/iter.html">Iterators</a></li>
<li><strong>Rust Patterns (Lazy Evaluation)</strong>: <a href="https://rust-unofficial.github.io/patterns/idioms/lazy-evaluation.html">Idioms</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-6-purely-functional-state"><a class="header" href="#chapter-6-purely-functional-state">Chapter 6: Purely Functional State</a></h1>
<p>Handling state without side effects is a core aspect of functional programming. We use the <strong>State Monad</strong> pattern, where a state transition is a function <code>S -&gt; (A, S)</code>.</p>
<h2 id="61-generating-random-numbers-simple-rng"><a class="header" href="#61-generating-random-numbers-simple-rng">6.1 Generating random numbers (Simple RNG)</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait RNG {
    fn next_int(&amp;self) -&gt; (i32, Box&lt;dyn RNG&gt;);
}

#[derive(Clone)]
pub struct SimpleRNG {
    seed: i64,
}

impl SimpleRNG {
    pub fn new(seed: i64) -&gt; SimpleRNG {
        SimpleRNG { seed }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-61-non_negative_int"><a class="header" href="#exercise-61-non_negative_int">Exercise 6.1: non_negative_int</a></h3>
<h3 id="exercise-62-double"><a class="header" href="#exercise-62-double">Exercise 6.2: double</a></h3>
<h3 id="exercise-63-int_double-double_int-double3"><a class="header" href="#exercise-63-int_double-double_int-double3">Exercise 6.3: int_double, double_int, double3</a></h3>
<h3 id="exercise-64-ints"><a class="header" href="#exercise-64-ints">Exercise 6.4: ints</a></h3>
<h2 id="64-a-better-api-for-state-actions"><a class="header" href="#64-a-better-api-for-state-actions">6.4 A better API for state actions</a></h2>
<p>We define <code>Rand&lt;A&gt;</code> as a type alias for <code>Fn(RNG) -&gt; (A, RNG)</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Rand&lt;A&gt; = Box&lt;dyn Fn(Box&lt;dyn RNG&gt;) -&gt; (A, Box&lt;dyn RNG&gt;)&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-65-double-via-map"><a class="header" href="#exercise-65-double-via-map">Exercise 6.5: double via map</a></h3>
<h3 id="exercise-66-map2"><a class="header" href="#exercise-66-map2">Exercise 6.6: map2</a></h3>
<h3 id="exercise-67-sequence"><a class="header" href="#exercise-67-sequence">Exercise 6.7: sequence</a></h3>
<h3 id="exercise-68-flat_map"><a class="header" href="#exercise-68-flat_map">Exercise 6.8: flat_map</a></h3>
<h3 id="exercise-69-map-and-map2-via-flat_map"><a class="header" href="#exercise-69-map-and-map2-via-flat_map">Exercise 6.9: map and map2 via flat_map</a></h3>
<h2 id="65-a-general-state-generic"><a class="header" href="#65-a-general-state-generic">6.5 A general State generic</a></h2>
<p>We generalize <code>Rand</code> to <code>State&lt;S, A&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct State&lt;S, A&gt;(pub Box&lt;dyn Fn(S) -&gt; (A, S)&gt;);
<span class="boring">}</span></code></pre></pre>
<h3 id="exercise-610-unit-map-map2-flat_map-sequence-for-state"><a class="header" href="#exercise-610-unit-map-map2-flat_map-sequence-for-state">Exercise 6.10: unit, map, map2, flat_map, sequence for State</a></h3>
<h2 id="66-purely-functional-imperative-programming"><a class="header" href="#66-purely-functional-imperative-programming">6.6 Purely functional imperative programming</a></h2>
<p>Using <code>State</code>, we can write imperative-looking code using <code>flat_map</code> chains.</p>
<h3 id="exercise-611-candy-machine"><a class="header" href="#exercise-611-candy-machine">Exercise 6.11: Candy Machine</a></h3>
<p>Implement a finite state automaton for a candy dispenser.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Input {
    Coin,
    Turn,
}

pub struct Machine {
    pub locked: bool,
    pub candies: i32,
    pub coins: i32,
}
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>Turn locked or Coin unlocked does nothing.</li>
<li>Machine out of candy ignores inputs.</li>
</ol>
<h2 id="67-references"><a class="header" href="#67-references">6.7 References</a></h2>
<ul>
<li><strong>Rust Book Ch 17 (State Object Pattern)</strong>: <a href="https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html">The Rust Programming Language</a></li>
<li><strong>Rust By Example (Traits)</strong>: <a href="https://doc.rust-lang.org/rust-by-example/trait.html">Traits</a></li>
<li><strong>Refactoring.Guru</strong>: <a href="https://refactoring.guru/design-patterns/state">State Pattern</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-7-purely-functional-parallelism"><a class="header" href="#chapter-7-purely-functional-parallelism">Chapter 7: Purely Functional Parallelism</a></h1>
<p>In this chapter, we will explore the design of a purely functional library for creating parallel and asynchronous computations. As we did in previous chapters, we won't jump straight to the implementation. Instead, we'll follow a process of <em>designing the API first</em>. We'll verify that our API is expressive and follows algebraic laws, and only <em>then</em> will we worry about how to implement it efficiently.</p>
<p>This journey is particularly interesting in Rust compared to Scala. In Scala, we can often be loose with thread safety due to the garbage collector and the JVM's memory model. In Rust, however, the compiler forces us to be rigorous about ownership and sharing across threads from day one. We will see how traits like <code>Send</code>, <code>Sync</code>, and types like <code>Arc</code> become fundamental building blocks of our parallel algebra.</p>
<h2 id="71-choosing-a-data-type-and-functions"><a class="header" href="#71-choosing-a-data-type-and-functions">7.1 Choosing a Data Type and Functions</a></h2>
<p>Our goal is to create a library that can describe parallel computations. Let's imagine we want to sum a list of integers in parallel. We might use a divide-and-conquer approach:</p>
<pre><code class="language-rust ignore">fn sum(ints: &amp;[i32]) -&gt; i32 {
    if ints.len() &lt;= 1 {
        ints.get(0).unwrap_or(&amp;0).clone() // equivalent to headOption.getOrElse(0)
    } else {
        let (l, r) = ints.split_at(ints.len() / 2);
        let sum_l = sum(l);
        let sum_r = sum(r);
        sum_l + sum_r
    }
}</code></pre>
<p>This implementation is sequential. To make it parallel, we need a way to say "compute <code>sum_l</code> and <code>sum_r</code> in parallel". Let's invent a container type, let's call it <code>Par&lt;A&gt;</code> (short for Parallel), that represents a computation of type <code>A</code> that <em>might</em> be running in another thread.</p>
<p>We need a way to take an unevaluated <code>A</code> and wrap it in a <code>Par&lt;A&gt;</code>. In Scala, this is <code>Par.unit</code>.
And we need a way to get the result out. Scala calls this <code>run</code>.</p>
<pre><code class="language-rust ignore">pub struct Par&lt;A&gt;(...);

impl&lt;A&gt; Par&lt;A&gt; {
    pub fn unit(a: A) -&gt; Par&lt;A&gt; { ... }
    pub fn run(self) -&gt; A { ... }
}</code></pre>
<p>If we change <code>sum</code> to use <code>Par</code>:</p>
<pre><code class="language-rust ignore">fn sum(ints: &amp;[i32]) -&gt; i32 {
    if ints.len() &lt;= 1 {
        // ...
    } else {
        let (l, r) = ints.split_at(ints.len() / 2);
        // unit returns Par&lt;i32&gt; immediately
        let sum_l: Par&lt;i32&gt; = Par::unit(sum(l)); 
        let sum_r: Par&lt;i32&gt; = Par::unit(sum(r));
        // get results (run)
        sum_l.run() + sum_r.run()
    }
}</code></pre>
<p>But wait! <code>Par::unit</code> takes an <em>evaluated</em> value <code>A</code>. If we pass <code>sum(l)</code> to it, <code>sum(l)</code> is evaluated <em>before</em> <code>unit</code> is called, on the current thread. We haven't achieved parallelism; we've just wrapped the result!</p>
<p>We need a primitive that takes a <em>lazy</em> argument or a closure. Let's call it <code>fork</code>.</p>
<pre><code class="language-rust ignore">pub fn fork&lt;A, F&gt;(a: F) -&gt; Par&lt;A&gt; 
where F: FnOnce() -&gt; Par&lt;A&gt; + Send + 'static { ... }</code></pre>
<p>In Rust, strict evaluation is the default. To prevent immediate execution, we pass a closure (a thunk). <code>fork</code> should take a thunk that returns a <code>Par&lt;A&gt;</code>, and run that thunk in a separate thread.</p>
<p>However, <code>fork</code> shouldn't just run <em>anything</em>. It specifically handles <code>Par</code>. To combine results, we need <code>map2</code>:</p>
<pre><code class="language-rust ignore">pub fn map2&lt;A, B, C, F&gt;(pa: Par&lt;A&gt;, pb: Par&lt;B&gt;, f: F) -&gt; Par&lt;C&gt;
where F: Fn(A, B) -&gt; C { ... }</code></pre>
<p>With <code>unit</code>, <code>fork</code>, and <code>map2</code>, our <code>sum</code> looks like this:</p>
<pre><code class="language-rust ignore">fn sum(ints: &amp;[i32]) -&gt; Par&lt;i32&gt; {
    if ints.len() &lt;= 1 {
        Par::unit(ints.get(0).copied().unwrap_or(0))
    } else {
        let (l, r) = ints.split_at(ints.len() / 2);
        Par::map2(
            Par::fork(|| sum(l)),
            Par::fork(|| sum(r)),
            |a, b| a + b
        )
    }
}</code></pre>
<p>This looks purely functional! <code>sum</code> now returns a <em>description</em> of a parallel computation (<code>Par&lt;i32&gt;</code>), which we can execute later by calling <code>run</code>.</p>
<h2 id="72-a-function-representation-for-par"><a class="header" href="#72-a-function-representation-for-par">7.2 A Function Representation for <code>Par</code></a></h2>
<p>What should <code>Par&lt;A&gt;</code> actually <em>be</em>?
In the book, <code>Par[A]</code> is defined as a function that takes an <code>ExecutorService</code> and returns a <code>Future[A]</code>.</p>
<pre><code class="language-scala">type Par[A] = ExecutorService =&gt; Future[A]
</code></pre>
<p>In Rust, this translates to something slightly more complex due to ownership.
We need an <code>Executor</code> trait (similar to <code>ExecutorService</code>).
We need a <code>Future</code> trait.
And <code>Par&lt;A&gt;</code> is a closure.</p>
<h3 id="the-rust-implementation-challenges"><a class="header" href="#the-rust-implementation-challenges">The Rust Implementation Challenges</a></h3>
<ol>
<li><strong>Object Safety</strong>: We want to pass <code>&amp;dyn Executor</code> around. This requires <code>Executor</code> to be "object safe". We cannot have generic methods like <code>submit&lt;T&gt;(...)</code> in an object-safe trait. We must use type erasure, e.g., <code>Box&lt;dyn Any + Send&gt;</code>.</li>
<li><strong>Thread Safety</strong>: Since <code>Par</code> is executed potentially on other threads, the closure defining it must be <code>Send</code> and <code>Sync</code>. We use <code>Arc</code> instead of <code>Rc</code> to allow shared ownership across threads.</li>
</ol>
<p>Here is our refined definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use std::any::Any;

#[allow(clippy::type_complexity)]
pub struct Par&lt;A&gt;(Arc&lt;dyn Fn(&amp;dyn Executor) -&gt; Box&lt;dyn Future&lt;Item=A&gt;&gt; + Send + Sync&gt;);
<span class="boring">}</span></code></pre></pre>
<p>This says: <code>Par&lt;A&gt;</code> assumes it can be shared (<code>Arc</code>), run concurrently (<code>Sync</code>), and sent across threads (<code>Send</code>). It takes an <code>Executor</code> and produces a <code>Future</code> yielding <code>A</code>.</p>
<h2 id="73-combinators"><a class="header" href="#73-combinators">7.3 Combinators</a></h2>
<p>Now we can implement the combinators.</p>
<h3 id="unit-and-lazy_unit"><a class="header" href="#unit-and-lazy_unit"><code>unit</code> and <code>lazy_unit</code></a></h3>
<p><code>unit</code> wraps a value immediately.
<code>lazy_unit</code> wraps a computation lazily by combining <code>unit</code> and <code>fork</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn unit&lt;A: Clone + Send + Sync + 'static&gt;(a: A) -&gt; Par&lt;A&gt; {
    Par::new(move |_| Box::new(UnitFuture(a.clone())))
}

pub fn lazy_unit&lt;A, F&gt;(a: F) -&gt; Par&lt;A&gt; 
where A: Clone + Send + Sync + 'static, F: Fn() -&gt; A + Send + Sync + 'static + Clone {
    fork(move || unit(a()))
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: The <code>Clone</code> bounds are often necessary in our simple implementation because the description of a parallel computation might be reused or re-executed. In a production library like <code>rayon</code>, generic lifetimes are handled more carefully to avoid excessive cloning.</p>
</blockquote>
<h3 id="map2"><a class="header" href="#map2"><code>map2</code></a></h3>
<p><code>map2</code> is where the magic happens. It combines two parallel computations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn map2&lt;A, B, C, F&gt;(pa: Par&lt;A&gt;, pb: Par&lt;B&gt;, f: F) -&gt; Par&lt;C&gt; {
    Par::new(move |es| {
        let fa = (pa.0)(es); // start A
        let fb = (pb.0)(es); // start B
        let a = fa.get();    // wait for A
        let b = fb.get();    // wait for B
        Box::new(UnitFuture(f(a, b)))
    })
}
<span class="boring">}</span></code></pre></pre>
<h3 id="fork"><a class="header" href="#fork"><code>fork</code></a></h3>
<p><code>fork</code> is responsible for shifting execution to a separate logical thread.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fork&lt;A, F&gt;(a: F) -&gt; Par&lt;A&gt; {
    Par::new(move |es| {
        // Submit a task to the executor
        let future = es.submit(wrapped_task);
        // Return a future that waits for the result
        ...
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="74-laws-and-deadlocks"><a class="header" href="#74-laws-and-deadlocks">7.4 Laws and Deadlocks</a></h2>
<p>An important property we expect is:
<code>fork(x) == x</code></p>
<p>Forking a computation shouldn't change its result, only <em>where</em> it runs.
However, with a fixed-size thread pool, naïve implementations of <code>fork</code> can deadlock!
If the thread pool has 1 thread:</p>
<ol>
<li><code>fork(fork(x))</code> is called.</li>
<li>The outer <code>fork</code> consumes the thread.</li>
<li>It tries to run the inner <code>fork</code>.</li>
<li>The inner <code>fork</code> waits for a thread... but the only thread is blocked waiting for the inner <code>fork</code>!</li>
</ol>
<p>This teaches us that <strong>API design is not just about types, but about runtime semantics and laws</strong>. A correct <code>Par</code> implementation for fixed-size pools requires non-blocking futures (using callbacks), which allows the thread to be released while waiting.</p>
<h2 id="75-derived-combinators"><a class="header" href="#75-derived-combinators">7.5 Derived Combinators</a></h2>
<p>Using <code>map2</code>, <code>unit</code>, and <code>fork</code>, we can derive:</p>
<ul>
<li><code>async_f</code>: Lift a function <code>A -&gt; B</code> to <code>A -&gt; Par&lt;B&gt;</code>.</li>
<li><code>sequence</code>: Convert <code>Vec&lt;Par&lt;A&gt;&gt;</code> to <code>Par&lt;Vec&lt;A&gt;&gt;</code>.</li>
<li><code>par_filter</code>: Filter a list in parallel.</li>
<li><code>map</code>: Derive <code>map</code> from <code>map2</code> and <code>unit</code>.</li>
</ul>
<h3 id="exercise-711-choice"><a class="header" href="#exercise-711-choice">Exercise 7.11: <code>choice</code></a></h3>
<p>We realized we can choose between two computations based on a boolean condition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn choice&lt;A&gt;(cond: Par&lt;bool&gt;, t: Par&lt;A&gt;, f: Par&lt;A&gt;) -&gt; Par&lt;A&gt;
<span class="boring">}</span></code></pre></pre>
<p>This naturally generalizes to <code>choice_n</code> (choosing from a list) and finally:</p>
<h3 id="exercise-713-flat_map-chooser"><a class="header" href="#exercise-713-flat_map-chooser">Exercise 7.13: <code>flat_map</code> (chooser)</a></h3>
<p>The most general form of dynamic choice is <code>flat_map</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn flat_map&lt;A, B, F&gt;(pa: Par&lt;A&gt;, f: F) -&gt; Par&lt;B&gt;
where F: Fn(A) -&gt; Par&lt;B&gt;
<span class="boring">}</span></code></pre></pre>
<p><code>flat_map</code> allows the structure of the computation to depend on the <em>result</em> of previous computations.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter, we built a functional parallelism library. We saw how:</p>
<ol>
<li><strong>Pure descriptions</strong> (<code>Par</code>) separate the "what" from the "how" (the <code>Executor</code>).</li>
<li><strong>Strictness in Rust</strong> requires explicit thunks or closures (like <code>F: Fn() -&gt; A</code>) to achieve laziness.</li>
<li><strong>Thread safety</strong> in Rust is explicit (<code>Send</code>, <code>Sync</code>, <code>Arc</code>), ensuring our parallel library prevents data races at compile time—a guarantee Scala cannot easily provide.</li>
</ol>
<p>In the next chapter, we will explore <strong>Property-Based Testing</strong>, where we will use generative testing to verifying laws like <code>fork(x) == x</code> automatically.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-8-property-based-testing"><a class="header" href="#chapter-8-property-based-testing">Chapter 8: Property-Based Testing</a></h1>
<p>In this chapter, we design a library for <strong>Property-Based Testing</strong>, similar to QuickCheck or ScalaCheck. The goal is to separate the <em>specification</em> of program behavior from the <em>generation</em> of test cases.</p>
<p>Instead of writing individual test scenarios (e.g., "reversing [1, 2, 3] yields [3, 2, 1]"), we define properties that should hold for <em>all</em> inputs (e.g., "reversing a list twice yields the original list"). The library then automatically generates random inputs to verify these properties.</p>
<h2 id="81-data-types-for-testing"><a class="header" href="#81-data-types-for-testing">8.1 Data Types for Testing</a></h2>
<p>We need two core data types:</p>
<ol>
<li><strong><code>Gen&lt;A&gt;</code></strong>: A generator that knows how to produce values of type <code>A</code>.</li>
<li><strong><code>Prop</code></strong>: A property that can be checked, resulting in success or failure.</li>
</ol>
<h3 id="811-generators-gen"><a class="header" href="#811-generators-gen">8.1.1 Generators (<code>Gen</code>)</a></h3>
<p>A generator is essentially a state transition over a random number generator. In Chapter 6, we built <code>State&lt;RNG, A&gt;</code>. <code>Gen&lt;A&gt;</code> is simply a wrapper around this state.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Gen&lt;A&gt;(State&lt;SimpleRNG, A&gt;);
<span class="boring">}</span></code></pre></pre>
<p>This allows us to leverage all the combinators we wrote for <code>State</code>, like <code>map</code> and <code>flat_map</code>, to compose complex generators from simple ones.</p>
<h4 id="primitives"><a class="header" href="#primitives">Primitives</a></h4>
<ul>
<li><strong><code>choose(start, stop)</code></strong>: Generates an integer in a range.</li>
<li><strong><code>unit(a)</code></strong>: Always generates the value <code>a</code>.</li>
<li><strong><code>boolean()</code></strong>: Generates a random boolean.</li>
</ul>
<h4 id="combinators"><a class="header" href="#combinators">Combinators</a></h4>
<ul>
<li><strong><code>list_of_n(n, gen)</code></strong>: Generates a list of length <code>n</code> using the given generator.</li>
<li><strong><code>flat_map</code></strong>: Allows a generator to depend on the output of another generator.</li>
</ul>
<h3 id="812-properties-prop"><a class="header" href="#812-properties-prop">8.1.2 Properties (<code>Prop</code>)</a></h3>
<p>A property is something we can check. A simple boolean <code>check</code> is insufficient because we want to know <em>why</em> it failed (the counter-example) and how many tests passed.</p>
<p>Our <code>Prop</code> type encapsulates a function that takes configuration (max size, number of test cases) and a source of randomness, returning a <code>Result</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Prop(Rc&lt;dyn Fn(MaxSize, TestCases, SimpleRNG) -&gt; Result&gt;);

pub enum Result {
    Passed,
    Falsified(FailedCase, SuccessCount),
    Proved,
}
<span class="boring">}</span></code></pre></pre>
<p>We use <code>Rc&lt;dyn Fn...&gt;</code> to allow properties to be cloned and shared, which is essential when combining them (e.g., <code>prop1.and(prop2)</code>).</p>
<h2 id="82-test-case-minimization"><a class="header" href="#82-test-case-minimization">8.2 Test Case Minimization</a></h2>
<p>Debugging failures on massive inputs is hard. There are two main approaches to minimization:</p>
<ol>
<li><strong>Shrinking</strong>: Find a failure, then iteratively "shrink" the input to find a smaller failing case. (Used by QuickCheck/ScalaCheck).</li>
<li><strong>Sized Generation</strong>: Start with small inputs and gradually increase size. The first failure found is naturally small. (Used to some extent in Hedgehog).</li>
</ol>
<p>We implement <strong>Sized Generation</strong> via <code>SGen</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SGen&lt;A&gt;(Rc&lt;dyn Fn(i32) -&gt; Gen&lt;A&gt;&gt;);
<span class="boring">}</span></code></pre></pre>
<p><code>SGen</code> allows us to define generators that adapt to a requested size. <code>Prop</code> then iterates through sizes up to a maximum, ensuring we test small cases first.</p>
<h2 id="83-the-rust-implementation"><a class="header" href="#83-the-rust-implementation">8.3 The Rust Implementation</a></h2>
<h3 id="ownership-and-closures"><a class="header" href="#ownership-and-closures">Ownership and Closures</a></h3>
<p>Unlike Scala, Rust requires explicit management of ownership.</p>
<ul>
<li><strong><code>Gen</code></strong>: Wraps <code>State</code>, which uses <code>Rc</code> internally in our Ch 6 implementation. This makes <code>Gen</code> cheap to clone.</li>
<li><strong><code>Prop</code></strong>: Uses <code>Rc&lt;dyn Fn...&gt;</code> to store the check logic.</li>
<li><strong>Laziness</strong>: In Scala, <code>check(true)</code> is lazy by name. In Rust, we pass a closure <code>check(|| true)</code> to prevent immediate execution.</li>
</ul>
<h3 id="random-number-generation"><a class="header" href="#random-number-generation">Random Number Generation</a></h3>
<p>We reuse <code>SimpleRNG</code> from Chapter 6. A key challenge in Rust is that <code>RNG</code> is a trait. Passing <code>dyn RNG</code> around can be tricky due to object safety rules (especially if methods return <code>Box&lt;dyn RNG&gt;</code>). For this chapter, we specialized our implementation to use <code>SimpleRNG</code> directly to keep the focus on the property testing logic rather than generic trait juggling.</p>
<h2 id="84-example-verifying-listreverse"><a class="header" href="#84-example-verifying-listreverse">8.4 Example: Verifying <code>List::reverse</code></a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_list_reverse() {
    let small_int = Gen::&lt;i32&gt;::choose(0, 100);
    let reverse_prop = for_all_sgen(SGen::list_of(small_int), |ns: Vec&lt;i32&gt;| {
        let mut rev = ns.clone();
        rev.reverse();
        let mut revrev = rev.clone();
        revrev.reverse();
        ns == revrev
    });
    // Run the check
    let result = reverse_prop.check(10, 100, SimpleRNG::new(42));
    assert!(!result.is_falsified());
}
<span class="boring">}</span></code></pre></pre>
<p>This ensures that for any generated list of integers, reversing it twice yields the original list. If we tried this with a broken reverse implementation, <code>Prop</code> would find a counter-example (e.g., <code>[0, 1]</code>) and report it.</p>
<h2 id="85-summary"><a class="header" href="#85-summary">8.5 Summary</a></h2>
<p>We have built a powerful testing library from scratch. It demonstrates how functional design principles (composition, pure functions) apply to domain-specific languages like testing frameworks.</p>
<h2 id="86-references"><a class="header" href="#86-references">8.6 References</a></h2>
<ul>
<li><strong>Rust Book Ch 11 (Testing)</strong>: <a href="https://doc.rust-lang.org/book/ch11-00-testing.html">The Rust Programming Language</a></li>
<li><strong>Rust By Example (Testing)</strong>: <a href="https://doc.rust-lang.org/rust-by-example/testing.html">Testing</a></li>
<li><strong>Proptest (Crate)</strong>: <a href="https://altsysrq.github.io/proptest-book/intro.html">Official Book</a> - Real-world Property Testing in Rust.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-9-parser-combinators"><a class="header" href="#chapter-9-parser-combinators">Chapter 9: Parser Combinators</a></h1>
<p>In this chapter, we explore the design of a combinator library for creating parsers. We'll use JSON parsing as our motivating use case, but the primary goal is to gain further insight into purely functional design.</p>
<p>We will adopt an <strong>algebraic design</strong> approach. Instead of thinking about the internal representation of a parser first, we will start by designing the interface (the algebra)—the types and combinators we need—and specifying the laws they must satisfy. Only after we have a solid algebra will we worry about the concrete implementation.</p>
<h2 id="91-designing-an-algebra"><a class="header" href="#91-designing-an-algebra">9.1 Designing an Algebra</a></h2>
<p>A parser is a program that takes unstructured input (like a string or stream of tokens) and produces a structured output (like a syntax tree or a specific value). In a combinator library, we build complex parsers by composing simpler ones.</p>
<p>Let's start with the basics. We need a type <code>Parser&lt;A&gt;</code> representing a parser that produces a value of type <code>A</code>. We also need a way to run it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Parser&lt;A&gt; {
    fn run(&amp;self, input: &amp;str) -&gt; Result&lt;A, ParseError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>(Note: In our final implementation, <code>Parser</code> will be a struct wrapping a closure, but conceptually it's an interface provided by our library.)</p>
<h3 id="basic-primitives"><a class="header" href="#basic-primitives">Basic Primitives</a></h3>
<p>To parse a single character or string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn char(c: char) -&gt; Parser&lt;char&gt;;
pub fn string(s: String) -&gt; Parser&lt;String&gt;;
<span class="boring">}</span></code></pre></pre>
<p>We expect <code>run(char('a'), "a")</code> to return <code>Ok('a')</code>.</p>
<p>To combine parsers, we need an "or" combinator to choose between alternatives:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn or&lt;A&gt;(p1: Parser&lt;A&gt;, p2: Parser&lt;A&gt;) -&gt; Parser&lt;A&gt;;
<span class="boring">}</span></code></pre></pre>
<p>If <code>p1</code> fails, we try <code>p2</code>.</p>
<p>To handle repetition, we can introduce <code>many</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn many&lt;A&gt;(p: Parser&lt;A&gt;) -&gt; Parser&lt;Vec&lt;A&gt;&gt;;
<span class="boring">}</span></code></pre></pre>
<p>And to transform the result of a parser, <code>map</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn map&lt;A, B&gt;(p: Parser&lt;A&gt;, f: Fn(A) -&gt; B) -&gt; Parser&lt;B&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="context-sensitivity-and-flatmap"><a class="header" href="#context-sensitivity-and-flatmap">Context Sensitivity and <code>flatMap</code></a></h3>
<p>Some parsing tasks require <strong>context sensitivity</strong>, where the next parser depends on the result of the previous one. For example, parsing a header that specifies the length of the following body. To support this, we need <code>flat_map</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn flat_map&lt;A, B&gt;(p: Parser&lt;A&gt;, f: Fn(A) -&gt; Parser&lt;B&gt;) -&gt; Parser&lt;B&gt;;
<span class="boring">}</span></code></pre></pre>
<p>With <code>flat_map</code>, <code>map</code> and <code>product</code> (sequencing) can be derived.</p>
<h2 id="92-implementation"><a class="header" href="#92-implementation">9.2 Implementation</a></h2>
<p>Now, let's look at how we can implement this algebra in Rust. Unlike Scala, where we might use trait inheritance heavily, purely functional parser combinators in Rust are often elegantly implemented using <strong>functions</strong> (closures).</p>
<h3 id="the-parser-type"><a class="header" href="#the-parser-type">The Parser Type</a></h3>
<p>A <code>Parser&lt;A&gt;</code> acts as a function <code>Fn(&amp;Location) -&gt; Result&lt;(A, Location), ParseError&gt;</code>. It takes a current input location and returns either a success (value + new location) or an error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
#[allow(clippy::type_complexity)]
pub struct Parser&lt;A&gt;(Rc&lt;dyn Fn(&amp;Location) -&gt; Result&lt;(A, Location), ParseError&gt;&gt;);
<span class="boring">}</span></code></pre></pre>
<p>We use <code>Rc&lt;dyn Fn...&gt;</code> to allow parsers to be cloned and shared easily, which is crucial for combinators that reuse parsers (like <code>many</code> reusing the same parser in a loop).</p>
<h3 id="location-and-error-handling"><a class="header" href="#location-and-error-handling">Location and Error Handling</a></h3>
<p>To provide good error messages, we track the <code>Location</code> in the input string.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq)]
pub struct Location {
    pub input: Rc&lt;String&gt;,
    pub offset: usize,
}
<span class="boring">}</span></code></pre></pre>
<p>A <code>ParseError</code> contains a stack of errors, allowing us to provide detailed context (e.g., "Error in JSON object at key 'foo': expected ':'").</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq)]
pub struct ParseError {
    pub stack: Vec&lt;(Location, String)&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="combinators-1"><a class="header" href="#combinators-1">Combinators</a></h3>
<p>The implementation of <code>string</code> checks if the input at the current location starts with the target string.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn string(s: String) -&gt; Parser&lt;String&gt; {
    Parser::new(move |loc: &amp;Location| {
        let input_slice = &amp;loc.input[loc.offset..];
        if input_slice.starts_with(&amp;s) {
            Ok((s.clone(), Location::new(loc.input.clone(), loc.offset + s.len())))
        } else {
            Err(ParseError::new(loc.clone(), format!("Expected '{}'", s)))
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>or</code> combinator tries the first parser, and if it fails, tries the second.</p>
<p>The <code>flat_map</code> combinator runs the first parser, gets the result <code>a</code>, applies the function <code>f(a)</code> to get the second parser, and then runs that second parser.</p>
<h2 id="93-parsing-json"><a class="header" href="#93-parsing-json">9.3 Parsing JSON</a></h2>
<p>With just a few primitives (<code>string</code>, <code>regex</code> or equivalent, <code>flat_map</code>, <code>or</code>, <code>many</code>), we can build a fully functional JSON parser.</p>
<p>We can define a <code>JSON</code> enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum JSON {
    JNull,
    JBool(bool),
    JNumber(f64),
    JString(String),
    JArray(Vec&lt;JSON&gt;),
    JObject(HashMap&lt;String, JSON&gt;),
}
<span class="boring">}</span></code></pre></pre>
<p>And then compose our parsers to handle objects, arrays, and values recursively. Since JSON is recursive, we need to handle deferred execution properly (e.g., using <code>Parser::new</code> to wrap recursive calls).</p>
<h2 id="94-conclusion"><a class="header" href="#94-conclusion">9.4 Conclusion</a></h2>
<p>In this chapter, we saw how algebraic design leads us to a flexible and powerful set of combinators. By focusing on the interface and laws first, we identified the core primitives (<code>flat_map</code>, <code>or</code>, <code>string</code>) needed to handle complex parsing tasks like JSON. The resulting implementation in Rust, leveraging closures and type-safe enums, is both expressive and efficient.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-10-monoids"><a class="header" href="#chapter-10-monoids">Chapter 10: Monoids</a></h1>
<p>In this chapter, we explore one of the simplest and most ubiquitous algebraic structures: the <strong>Monoid</strong>. This serves as our introduction to purely algebraic structures, defined solely by their operations and laws.</p>
<h2 id="101-what-is-a-monoid"><a class="header" href="#101-what-is-a-monoid">10.1 What is a Monoid?</a></h2>
<p>A monoid consists of:</p>
<ol>
<li>A type <code>A</code>.</li>
<li>An associative binary operation <code>op(a1, a2): A</code>.</li>
<li>An identity element <code>zero: A</code> such that <code>op(x, zero) == x</code> and <code>op(zero, x) == x</code>.</li>
</ol>
<p>In Rust, we can define this as a trait. Since a single type can have multiple monoid instances (e.g., integers can be a monoid under addition or multiplication), we define the trait on a struct representing the monoid logic, rather than on the data type itself (using the "type class instance" pattern).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Monoid&lt;A&gt; {
    fn op(&amp;self, a1: A, a2: A) -&gt; A;
    fn zero(&amp;self) -&gt; A;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p><strong>String Monoid</strong>: Concatenation is associative, and the empty string is the identity.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct StringMonoid;
impl Monoid&lt;String&gt; for StringMonoid {
    fn op(&amp;self, a1: String, a2: String) -&gt; String { a1 + &amp;a2 }
    fn zero(&amp;self) -&gt; String { "".to_string() }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Int Addition</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntAddition;
impl Monoid&lt;i32&gt; for IntAddition {
    fn op(&amp;self, a1: i32, a2: i32) -&gt; i32 { a1 + a2 }
    fn zero(&amp;self) -&gt; i32 { 0 }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="102-folding-with-monoids"><a class="header" href="#102-folding-with-monoids">10.2 Folding with Monoids</a></h2>
<p>Monoids are intimately related to folding lists. If we have a list of values <code>[a, b, c]</code> and a monoid for that type, we can reduce the list to a single value by combining them: <code>op(a, op(b, c))</code>.</p>
<p>We can generalize this to <code>fold_map</code>. If we have a list of type <code>A</code>, and a function <code>f: A -&gt; B</code> where <code>B</code> has a monoid instance, we can map every element to <code>B</code> and then combine them.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fold_map&lt;A, B, M, F&gt;(as_: Vec&lt;A&gt;, m: M, f: F) -&gt; B 
where M: Monoid&lt;B&gt;, F: Fn(A) -&gt; B {
    as_.into_iter().fold(m.zero(), |acc, x| m.op(acc, f(x)))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="103-associativity-and-parallelism"><a class="header" href="#103-associativity-and-parallelism">10.3 Associativity and Parallelism</a></h2>
<p>The associativity law (<code>op(op(a, b), c) == op(a, op(b, c))</code>) means we don't have to fold sequentially from left to right. We can use a <strong>balanced fold</strong>, splitting the list in half, reducing each half recursively, and then combining the results. This enables parallelism.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn fold_map_v&lt;A, B, M, F&gt;(v: &amp;[A], m: &amp;M, f: &amp;F) -&gt; B
where M: Monoid&lt;B&gt;, F: Fn(&amp;A) -&gt; B + Clone, B: Clone {
    if v.is_empty() {
        m.zero()
    } else if v.len() == 1 {
        f(&amp;v[0])
    } else {
        let (left, right) = v.split_at(v.len() / 2);
        let lb = fold_map_v(left, m, f);
        let rb = fold_map_v(right, m, f);
        m.op(lb, rb)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="104-example-word-count"><a class="header" href="#104-example-word-count">10.4 Example: Word Count</a></h2>
<p>A practical use case for parallel folding is counting words in a large string. If we split a string in the middle, we might split a word. To handle this, we define a specialized monoid <code>WC</code> (Word Count).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum WC {
    Stub(String), // Partial word
    Part(String, i32, String), // (Left partial, count of full words, Right partial)
}
<span class="boring">}</span></code></pre></pre>
<p>The monoid operation combines these parts, merging adjacent stubs to form complete words if necessary.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Monoid&lt;WC&gt; for WCMonoid {
    fn op(&amp;self, a1: WC, a2: WC) -&gt; WC {
        match (a1, a2) {
            (WC::Stub(c), WC::Stub(d)) =&gt; WC::Stub(c + &amp;d),
            (WC::Stub(c), WC::Part(l, w, r)) =&gt; WC::Part(c + &amp;l, w, r),
            // ... logic to merge parts ...
        }
    }
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>By mapping every character to a <code>WC</code> (whitespace becomes <code>Part("", 0, "")</code>, non-whitespace becomes <code>Stub(c)</code>), we can use <code>fold_map_v</code> to count words in parallel.</p>
<h2 id="105-conclusion"><a class="header" href="#105-conclusion">10.5 Conclusion</a></h2>
<p>Monoids provide a simple but powerful abstraction for combining values. Their laws ensure that operations like parallel folding are safe and correct. This sets the stage for more complex algebraic structures like Functors and Monads, which we will explore in the next chapters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-11-monads"><a class="header" href="#chapter-11-monads">Chapter 11: Monads</a></h1>
<p>In this chapter, we generalize the patterns we've seen in <code>Gen</code>, <code>Parser</code>, <code>Option</code>, and <code>State</code>. We identify two key abstractions: the <strong>Functor</strong> and the <strong>Monad</strong>.</p>
<h2 id="111-functors"><a class="header" href="#111-functors">11.1 Functors</a></h2>
<p>A Functor is a type constructor <code>F</code> that provides a <code>map</code> function. In Scala, this is represented as <code>trait Functor[F[_]]</code>. In Rust, we lack native support for Higher-Kinded Types (HKTs) (i.e., types that take other types as type arguments, like <code>Option</code> itself, not <code>Option&lt;i32&gt;</code>).</p>
<p>To work around this, we use <strong>Generic Associated Types (GATs)</strong>, a feature stabilized in Rust 1.65. We define a trait that has an associated type <code>Wrapped&lt;A&gt;</code> representing <code>F&lt;A&gt;</code>.</p>
<blockquote>
<p>[!NOTE]
Learn more about GATs in the <a href="https://blog.rust-lang.org/2022/10/28/gats-stabilization.html">Official Rust Blog Post</a>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Functor {
    type Wrapped&lt;A&gt;;
    
    fn map&lt;A, B, F&gt;(fa: Self::Wrapped&lt;A&gt;, f: F) -&gt; Self::Wrapped&lt;B&gt; 
    where F: Fn(A) -&gt; B;
}
<span class="boring">}</span></code></pre></pre>
<p>This allows us to write generic code that works for any Functor, provided we implement the trait for a specific "Monad Type" (like <code>OptionMonad</code> acts as the descriptor for <code>Option</code>).</p>
<h2 id="112-monads"><a class="header" href="#112-monads">11.2 Monads</a></h2>
<p>The Monad abstraction adds <code>unit</code> and <code>flatMap</code> (often called <code>bind</code> or <code>&gt;&gt;=</code> in other languages).</p>
<p>Make note that <strong>Rust's standard library</strong> uses the term <code>and_then</code> for <code>Option</code> and <code>Result</code>, and <code>flat_map</code> for <code>Iterator</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Monad: Functor {
    fn unit&lt;A&gt;(a: A) -&gt; Self::Wrapped&lt;A&gt;;
    
    fn flat_map&lt;A, B, F&gt;(ma: Self::Wrapped&lt;A&gt;, f: F) -&gt; Self::Wrapped&lt;B&gt;
    where F: Fn(A) -&gt; Self::Wrapped&lt;B&gt;;
    
    // ... map2 ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-map2-challenge-in-rust"><a class="header" href="#the-map2-challenge-in-rust">The <code>map2</code> Challenge in Rust</a></h3>
<p>In functional theory, <code>map2</code> can be derived from <code>flatMap</code> and <code>map</code>. However, in Rust, implementing <code>map2</code> generically via <code>flatMap</code> involves closures.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Conceptual default implementation
flat_map(ma, |a| map(mb, |b| f(a, b)))
<span class="boring">}</span></code></pre></pre>
<p>This inner closure <code>|b| f(a, b)</code> captures <code>a</code> and <code>f</code>. If the Monad executes this closure multiple times (like <code>Vec</code>/List monad, which handles non-determinism), <code>f</code> and <code>a</code> must be clonable. Because of this complexity in a generic context, we essentially require <code>map2</code> to be implemented (or specialized) by the instance, or we impose <code>Clone</code> bounds on the function <code>F</code> and the values.</p>
<h2 id="113-instances"><a class="header" href="#113-instances">11.3 Instances</a></h2>
<p>We implemented Monad instances for:</p>
<ul>
<li><strong>Option</strong>: Simple sequencing. Failure short-circuits. Equivalent to <code>Option::and_then</code>.</li>
<li><strong>Vec (List)</strong>: Represents non-determinism. <code>flatMap</code> applies the function to each element and concatenates the results. Equivalent to <code>Iterator::flat_map</code>.</li>
<li><strong>Id</strong>: The identity monad, wrapping a value directly.</li>
<li><strong>Result</strong>: Similar to Option but carries an error value. Equivalent to <code>Result::and_then</code>.</li>
</ul>
<h2 id="114-combinators"><a class="header" href="#114-combinators">11.4 Combinators</a></h2>
<p>Once we have the <code>Monad</code> trait, we can define powerful combinators that work for <em>any</em> monad:</p>
<ul>
<li><strong><code>sequence</code></strong>: Turns a <code>Vec&lt;M&lt;A&gt;&gt;</code> into <code>M&lt;Vec&lt;A&gt;&gt;</code>.</li>
<li><strong><code>traverse</code></strong>: Maps a function <code>A -&gt; M&lt;B&gt;</code> over a list and collects the results.</li>
<li><strong><code>replicateM</code></strong>: Generates a list of <code>n</code> values from sequencing a monad.</li>
<li><strong><code>filterM</code></strong>: A powerful combinator that filters a list based on a monadic predicate. For <code>Vec</code> (List Monad), this generates the powerset (all subsequences) of a list!</li>
</ul>
<h2 id="115-conclusion"><a class="header" href="#115-conclusion">11.5 Conclusion</a></h2>
<p>Monads provide a unified interface for sequencing operations. Despite Rust's type system differences from Scala (lack of HKTs), we can effectively model these concepts using GATs, allowing us to write reusable, generic control flow logic.</p>
<h2 id="116-references"><a class="header" href="#116-references">11.6 References</a></h2>
<ul>
<li><strong>Rust Blog (GATs)</strong>: <a href="https://blog.rust-lang.org/2022/10/28/gats-stabilization.html">Stabilization Announcement</a></li>
<li><strong>Rust By Example (Traits)</strong>: <a href="https://doc.rust-lang.org/rust-by-example/trait.html">Traits</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-12-applicative-and-traversable-functors"><a class="header" href="#chapter-12-applicative-and-traversable-functors">Chapter 12: Applicative and Traversable Functors</a></h1>
<p>In this chapter, we discover that <strong>Monad</strong> is not the only useful abstraction for effectful computation. We introduce <strong>Applicative</strong>, which is generally "weaker" than Monad (it can do less) but also more general (more things are Applicatives) and allows for different behaviors, such as parallel execution and error accumulation. We then generalize the <code>traverse</code> and <code>sequence</code> functions into the <strong>Traverse</strong> trait.</p>
<h2 id="121-applicative-functors"><a class="header" href="#121-applicative-functors">12.1 Applicative Functors</a></h2>
<p>A Monad is defined by <code>unit</code> and <code>flatMap</code>.
An Applicative is defined by <code>unit</code> and <code>map2</code> (or <code>apply</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Applicative: Functor {
    fn unit&lt;A&gt;(a: A) -&gt; Self::Wrapped&lt;A&gt;; // Same as Monad
    
    fn map2&lt;A, B, C, F&gt;(
        fa: Self::Wrapped&lt;A&gt;,
        fb: Self::Wrapped&lt;B&gt;,
        f: F
    ) -&gt; Self::Wrapped&lt;C&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="why-applicative"><a class="header" href="#why-applicative">Why Applicative?</a></h3>
<p>If we look at <code>map2</code> vs <code>flatMap</code>:</p>
<ul>
<li><code>flatMap</code> allows the <em>structure</em> of the second computation to depend on the <em>result</em> of the first.</li>
<li><code>map2</code> takes two independent computations and combines their results.</li>
</ul>
<p>This independence means:</p>
<ol>
<li><strong>Parallelism</strong>: Since <code>fa</code> and <code>fb</code> are independent, they can be computed in parallel (e.g., fetching two URLs).</li>
<li><strong>Analysis</strong>: We can inspect the structure of the computation without running it.</li>
<li><strong>Accumulation</strong>: We can accumulate errors from both branches (e.g., form validation), whereas <code>flatMap</code> usually stops at the first error.</li>
</ol>
<h2 id="122-traversable-functors"><a class="header" href="#122-traversable-functors">12.2 Traversable Functors</a></h2>
<p>We've seen <code>traverse</code> and <code>sequence</code> for List, Option, and Map. We can abstract this into a <strong>Traverse</strong> trait.</p>
<p>A Traversable functor allows us to iterate over a data structure (like a Tree or List) while maintaining an effect (Applicative) context.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Traverse: Functor { // actually extends Functor and Foldable conceptually
    fn traverse&lt;G, A, B, F&gt;(
        fa: Self::Wrapped&lt;A&gt;,
        f: F
    ) -&gt; G::Wrapped&lt;Self::Wrapped&lt;B&gt;&gt;
    where G: Applicative;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-tree-traversal"><a class="header" href="#example-tree-traversal">Example: Tree Traversal</a></h3>
<p>If we have a <code>Tree&lt;i32&gt;</code> and we want to apply a function that might fail (returning <code>Option&lt;i32&gt;</code>) to every node, <code>traverse</code> will give us <code>Option&lt;Tree&lt;i32&gt;&gt;</code>. It turns the "Tree of Options" into an "Option of Tree".</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Traverse for TreeApp {
    fn traverse&lt;G, A, B, F&gt;(fa: Tree&lt;A&gt;, f: F) -&gt; G::Wrapped&lt;Tree&lt;B&gt;&gt;
    where G: Applicative, ... {
        match fa {
            Tree::Leaf(a) =&gt; G::map(f(a), |b| Tree::Leaf(b)),
            Tree::Branch(l, r) =&gt; {
                let gl = Self::traverse(*l, f.clone());
                let gr = Self::traverse(*r, f);
                G::map2(gl, gr, |l, r| Tree::Branch(Box::new(l), Box::new(r)))
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="123-conclusion"><a class="header" href="#123-conclusion">12.3 Conclusion</a></h2>
<p>Applicative and Traversable complete our tour of the core functional type classes. They allow us to write extremely generic code for data manipulation, separating the <em>mechanism</em> of the effect (Option, Result, Async) from the <em>structure</em> of the data (List, Tree, Map). In Rust, using generic traits and GATs allows us to express these powerful abstractions in a type-safe way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-13-external-effects-and-io"><a class="header" href="#chapter-13-external-effects-and-io">Chapter 13: External Effects and I/O</a></h1>
<p>This chapter explores how to handle "external effects" (like reading files, printing to console, or network calls) in a purely functional way. The core idea is to separate the <strong>description</strong> of the computation from its <strong>execution</strong>.</p>
<blockquote>
<p>[!NOTE]
In idiomatic Rust, I/O is typically handled imperatively with <code>std::io</code> or asynchronously with <code>Future</code> (which is monad-like!). This chapter explores the <em>pure functional modeling</em> of I/O, which powers the design of async runtimes.</p>
</blockquote>
<h2 id="131-the-io-type"><a class="header" href="#131-the-io-type">13.1 The IO Type</a></h2>
<p>We can model an effectful computation as a value that, when "run", performs the effect. In its simplest form, this is just a wrapper around a function (a thunk).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SimpleIO&lt;A&gt;(Box&lt;dyn FnOnce() -&gt; A&gt;);

impl&lt;A&gt; SimpleIO&lt;A&gt; {
    pub fn new&lt;F&gt;(f: F) -&gt; Self where F: FnOnce() -&gt; A + 'static { 
        SimpleIO(Box::new(f)) 
    }
    
    pub fn run(self) -&gt; A { (self.0)() }
    
    pub fn flat_map&lt;B, F&gt;(self, f: F) -&gt; SimpleIO&lt;B&gt;
    where F: FnOnce(A) -&gt; SimpleIO&lt;B&gt; + 'static
    {
        SimpleIO::new(move || f(self.run()).run())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="132-composition"><a class="header" href="#132-composition">13.2 Composition</a></h2>
<p>Since <code>IO</code> is a description, we can compose these descriptions. <code>IO</code> forms a Monad.</p>
<ul>
<li><strong><code>map</code></strong>: Transform the result of an effect description.</li>
<li><strong><code>flatMap</code></strong>: Chain effects, where the second effect depends on the result of the first.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let program = Console::read_line()
    .flatMap(|name| Console::print_line(&amp;format!("Hello, {}!", name)));
<span class="boring">}</span></code></pre></pre>
<p>Until we call <code>program.run()</code>, nothing happens. This is <strong>Referential Transparency</strong>: the expression <code>program</code> can be replaced by its definition without changing the outcome (because the outcome <em>is just a description</em>, not the side effect itself).</p>
<h2 id="133-limitations-and-the-free-monad"><a class="header" href="#133-limitations-and-the-free-monad">13.3 Limitations and The Free Monad</a></h2>
<p>Our simple <code>IO</code> type has a flaw: it uses the Rust call stack for <code>flatMap</code>. Deeply recursive programs (like an infinite event loop) will cause a <code>StackOverflowError</code>.</p>
<p>In Scala (and advanced Rust), we solve this using <strong>Trampolining</strong> or the <strong>Free Monad</strong>. This involves reifying the control flow (<code>FlatMap</code>, <code>Return</code>) as data structures rather than function calls. The interpreter then runs in a loop (a trampoline), keeping the stack constant.</p>
<p>Implementing a full generic <code>Free</code> monad in Rust is complex due to the lack of Higher-Kinded Types (HKT) and challenges with type erasure in <code>FlatMap</code>. Ideally, one would use a crate like <code>stacker</code> or specialized enum structures, but the conceptual model remains the same: <strong>Data as Control Flow</strong>.</p>
<h2 id="134-use-cases"><a class="header" href="#134-use-cases">13.4 Use Cases</a></h2>
<p>This pattern allows us to:</p>
<ol>
<li><strong>Test Effectful Code</strong>: We can inspect the description (if we use the <code>Free</code> enum approach) or swap interpreters.</li>
<li><strong>Safe Refactoring</strong>: We can refactor effectful sequences with the same confidence as pure logic.</li>
<li><strong>Custom Interpreters</strong>: We could run an <code>IO</code> program asynchronously, or log every step, just by changing the <code>run</code> function.</li>
</ol>
<blockquote>
<p>[!TIP]
Rust's <code>async</code>/<code>await</code> syntax effectively builds a state machine (a form of Free Monad or Coroutine) that the Executor (like <code>tokio</code>) interprets. Understanding <code>IO</code> monads clarifies how <code>async</code> works under the hood!</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-14-local-effects-and-mutable-state"><a class="header" href="#chapter-14-local-effects-and-mutable-state">Chapter 14: Local Effects and Mutable State</a></h1>
<p>In functional programming, we emphasize immutability. However, some algorithms (like Quicksort, HashMaps, or graph traversals) are naturally expressed with mutable state. The types <code>ST</code> (State Thread) and <code>STRef</code> allow us to use mutable state <em>locally</em> while remaining externally pure.</p>
<h2 id="141-purely-functional-in-place-mutation"><a class="header" href="#141-purely-functional-in-place-mutation">14.1 Purely Functional In-Place Mutation?</a></h2>
<p>It sounds like a contradiction. How can we have mutation in a pure function?
The key is <strong>Scope</strong>.
If a function allocates a mutable array, modifies it, and then returns a frozen (immutable) copy (or a result derived from it), and <em>no one else</em> ever saw the mutable version, then the function is pure from the outside.</p>
<h2 id="142-the-st-monad-in-rust"><a class="header" href="#142-the-st-monad-in-rust">14.2 The ST Monad in Rust</a></h2>
<p>We implemented <code>ST&lt;'a, A&gt;</code> where <code>'a</code> represents the "thread" or scope of the mutation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ST&lt;'a, A&gt; {
    run: Box&lt;dyn FnOnce() -&gt; A + 'a&gt;, // Closure capturing mutable 'a references
}
<span class="boring">}</span></code></pre></pre>
<h3 id="preventing-leakage"><a class="header" href="#preventing-leakage">Preventing Leakage</a></h3>
<p>The danger is leaking a mutable reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r = run_st(STRef::new(1)); // ERROR! Result cannot be STRef
<span class="boring">}</span></code></pre></pre>
<p>In Rust, we prevent this using Higher-Rank Trait Bounds (HRTB) in the <code>run_st</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait RunnableST&lt;A&gt; {
    fn apply&lt;'a&gt;(&amp;self) -&gt; ST&lt;'a, A&gt;;
}

pub fn run_st&lt;A&gt;(st: &amp;impl RunnableST&lt;A&gt;) -&gt; A { ... }
<span class="boring">}</span></code></pre></pre>
<p>Because <code>run_st</code> enforces that <code>RunnableST</code> works for <em>any</em> <code>'a</code> (<code>for&lt;'a&gt;</code>), the return type <code>A</code> cannot depend on <code>'a</code>. <code>STRef&lt;'a, T&gt;</code> depends on <code>'a</code>, so it cannot be returned. <code>Vec&lt;T&gt;</code> (via <code>freeze()</code>) does <em>not</em> depend on <code>'a</code>, so it is safe to return.</p>
<h2 id="143-comparison-with-rust-references"><a class="header" href="#143-comparison-with-rust-references">14.3 Comparison with Rust References</a></h2>
<p>Rust's borrow checker provides similar guarantees natively:</p>
<ul>
<li><code>&amp;mut T</code> ensures exclusive access (effectively a local state thread).</li>
<li>Lifetimes (<code>'a</code>) ensure references don't escape their owner.</li>
</ul>
<p>In a sense, <strong>Rust is the ST Monad</strong>. Every block of code with local variables is an implicit <code>ST</code> computation. However, the explicit <code>ST</code> monad is useful when we want to treat "stateful computations" as First-Class Values (e.g., to pass them around, combine them safely, or implement "Ghost Types" patterns).</p>
<h2 id="144-conclusion"><a class="header" href="#144-conclusion">14.4 Conclusion</a></h2>
<p>We now have the ability to write efficient, in-place algorithms (like the <code>partition</code> step of Quicksort) using the <code>ST</code> monad, wrapping them safely so they appear pure to the rest of the program.</p>
<h2 id="145-rust-equivalents"><a class="header" href="#145-rust-equivalents">14.5 Rust Equivalents</a></h2>
<ul>
<li><strong>Smart Pointers</strong>: <a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html">The Rust Book Ch 15</a></li>
<li><strong>Interior Mutability (<code>RefCell</code>)</strong>: <a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">The Rust Book Ch 15.5</a></li>
<li><strong>Lifetimes</strong>: <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">The Rust Book Ch 10.3</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-15-stream-processing-and-incremental-io"><a class="header" href="#chapter-15-stream-processing-and-incremental-io">Chapter 15: Stream Processing and Incremental I/O</a></h1>
<p>The final step in our journey is to handle I/O incrementally. We want to process data (like lines in a large file) without loading everything into memory (like <code>List</code> or <code>Vec</code>), but still retain the composability of <code>map</code>, <code>filter</code>, and <code>fold</code>.</p>
<h2 id="151-the-problem-with-io"><a class="header" href="#151-the-problem-with-io">15.1 The Problem with I/O</a></h2>
<p>Standard imperative I/O mixes the <em>what</em> (logic) with the <em>how</em> (looping, reading).
Standard functional <code>List</code> separates them but requires loading all data into memory first.</p>
<h2 id="152-the-process-algebra"><a class="header" href="#152-the-process-algebra">15.2 The Process Algebra</a></h2>
<p>We define <code>Process&lt;I, O&gt;</code> as a state machine that can:</p>
<ol>
<li><strong>Emit</strong> a value of type <code>O</code> and transition to a new state.</li>
<li><strong>Await</strong> a value of type <code>I</code> and transition to a new state.</li>
<li><strong>Halt</strong>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Process&lt;I, O&gt; {
    Emit(O, Box&lt;Process&lt;I, O&gt;&gt;),
    Await(Box&lt;dyn FnOnce(Option&lt;I&gt;) -&gt; Process&lt;I, O&gt;&gt;),
    Halt,
}
<span class="boring">}</span></code></pre></pre>
<p>This is a <strong>Pull-based</strong> stream. The driver calls the process; if the process is <code>Emit</code>ting, the driver collects the value. If the process is <code>Await</code>ing, the driver fetches inputs (e.g., from a file) and feeds them in.</p>
<h2 id="153-composition-the-pipe-"><a class="header" href="#153-composition-the-pipe-">15.3 Composition: The Pipe (<code>|&gt;</code>)</a></h2>
<p>The true power comes from <code>pipe</code>. We can feed the output of one process into the input of another.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p1 = Process::filter(|x| x % 2 == 0); // Producers/Transducers
let p2 = Process::lift(|x| x * 10);
let pipeline = p1.pipe(p2); // Fused Process
<span class="boring">}</span></code></pre></pre>
<p>The <code>pipe</code> implementation fuses the two machines into one. It runs <code>p2</code> until <code>p2</code> awaits input, then run <code>p1</code> to produce that input. This ensures <strong>constant memory usage</strong> (processing one element at a time) for arbitrary pipelines.</p>
<h2 id="154-conclusion"><a class="header" href="#154-conclusion">15.4 Conclusion</a></h2>
<p>This architecture (often called <strong>Iteratees</strong>, <strong>Transducers</strong>, or <strong>Pull Streams</strong>) is the foundation of modern functional streaming libraries like <code>fs2</code> (Scala) or <code>futures::Stream</code> (Rust). It allows us to process infinite streams or massive files with the same elegance as operating on small lists.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
